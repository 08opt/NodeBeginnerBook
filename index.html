<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link href="prettify/prettify.css" type="text/css" rel="stylesheet" />

		<title>The Node Beginner Book</title>

		<style type="text/css">
			body {
				font-family: Georgia, serif;
				background-color: #eee;
				padding-top: 48px;
			}

			#book, #disqus_thread, #footer {
				width: 840px;
				margin: 0 auto;
				margin-top: 24px;
				padding: 64px;
				background-color: white;
				border-top: 1px solid #ddd;
				border-left: 1px solid #ddd;
				border-bottom: 1px solid #ddd;
				border-right: 8px solid #ddd;
			}

			#author {
				margin-top: -41px;
				margin-left: 279px;
				color: #888;
			}

			#updateinfo {
				margin-top: -1px;
				margin-left: 279px;
				color: #bbb;
				font-size: 75%;
			}

			#workinprogressnote {
				margin-top: 80px;
				font-weight: bold;
				font-style: italic;
				color: #700;
			}

			#disqus_thread {
				
			}

			#footer {
				font-family: "Helvetica Neue", sans-serif;
				font-size: 11px;
				background-color: #f5f5f5;
			}

			#ccimage {
				float: left;
				margin-right: 12px;
			}

			h1 {
				margin-left: -63px;
				margin-top: -109px;
				font-size: 300%;
				color: #444;
			}

			h2 {
				margin-top: 48px;
				color: #700;
				font-size: 200%;
			}

			h3 {
				font-size: 160%;
			}

			h4 {
				font-size: 120%;
			}

			h3, h4 {
				margin-top: 36px;
				color: #700;
			}

			h2, h3, h4 {
				font-style: italic;
				font-weight: normal;
			}

			p {
				text-align: justify;
				font-size: 110%;
				line-height: 150%;
			}

			pre {
				background-color: #f7f7f7;
				border: 1px solid #eee;
				padding: 16px;
			}

			pre.prettyprint {
				background-color: #f7f7f7;
				border: 1px solid #eee;
				padding: 16px;
			}

			ul li {
				margin-bottom: 12px;
				font-size: 110%;
			}
		</style>
		<script type="text/javascript" src="prettify/prettify.js"></script>
		<script type="text/javascript">
			var _gaq = _gaq || [];
			_gaq.push(['_setAccount', 'UA-2127388-6']);
			_gaq.push(['_trackPageview']);

			(function() {
				var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
				ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
				var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
			})();
		</script>
	</head>
	<body onload="prettyPrint();">
		<a href="https://github.com/ManuelKiessling/NodeBeginnerBook"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://d3nwyuy0nl342s.cloudfront.net/img/71eeaab9d563c2b3c590319b398dd35683265e85/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" /></a>

		<div id="book">
			<h1>The Node Beginner Book</h1>
			<div id="author">by <a href="http://twitter.com/manuelkiessling">Manuel Kiessling</a></div>
			<div id="updateinfo">Last updated on Wednesday, April 19, 2011 at 7:57 AM EDT</div>


			<h2>About</h2>

			<p>
				The aim of this document is to get you started with developing
				applications for node.js, teaching you everything you need to
				know about "advanced" JavaScript along the way. It goes way
				beyond your typical "Hello World" tutorial.
			</p>

			<h3>Intended audience</h3>
			<p>
				This document will probably fit best for readers that have a
				background similar to my own: experienced with at least one
				object-oriented language like Ruby, Python, PHP or Java, only little
				experience with JavaScript, and completely new to node.js.
			</p>
			<p>
				Aiming at developers that already have experience with other
				programming languages means that this document won't cover
				really basic stuff like data types, variables, control structures
				and the likes. You already need to know about these to understand
				this document.
			</p>
			<p>
				However, because functions and objects in JavaScript are different
				from their counterparts in most other languages, these will be
				explained in more detail.
			</p>

			<h3>Structure of this document</h3>
			<p>
				Upon finishing this document, you will have created a complete web
				application which allows the users of this application to view web
				pages and upload files.
			</p>
			<p>
				Which, of course, is not exactly
				world-changing, but we will go some extra miles and not only create
				the code that is "just enough" to make these use cases possible,
				but create a simple, yet complete framework to cleanly separate the
				different aspects of our application. You will see what I mean in a
				minute.
			</p>
			<p>
				We will start with looking at how JavaScript development in node.js
				is different from JavaScript development in a browser.
			</p>
			<p>
				Next, we will stay with the good old tradition of writing a "Hello
				World" application, which is a most basic node.js application that
				"does" something.
			</p>
			<p>
				Then, we will discuss what kind of "real" application we want to
				build, dissect the different parts which need to be implemented to
				assemble this application, and start working on each of these parts
				step-by-step.
			</p>
			<p>
				As promised, along the way we will learn about some of the more
				advanced concepts of JavaScript, how to make use of them, and
				looking at why it makes sense to use these concepts instead of
				those we know from other programming languages.
			</p>


			<h2>JavaScript and node.js</h2>

			<h3>JavaScript and You</h3>
			<p>
				Before we talk about all the technical stuff, let's take a
				moment and talk about you and your relationship with
				JavaScript. This chapter is here to allow you to estimate
				if reading this document any further makes sense for you.
			</p>
			<p>
				If you are like me, you started with HTML "development"
				long ago, by writing HTML documents. You came along this
				funny thing called JavaScript, but you only used it in a
				very basic way, adding interactivity to your web pages
				every now and then.
			</p>
			<p>
				What you really wanted was "the real thing", you wanted to
				know how to build complex web sites - you learned a
				programming language like PHP, Ruby, Java, and started
				writing "backend" code.
			</p>
			<p>
				Nevertheless, you kept an eye on JavaScript, you saw that
				with the introduction of jQuery, Prototype and the likes,
				things got more advanced in JavaScript land, and that this
				language really was about more than <em>window.open()</em>.
			</p>
			<p>
				However, this was all still frontend stuff, and although it
				was nice to have jQuery at your disposal whenever you felt
				like spicing up a web page, at the end of the day you were,
				at best, a JavaScript <em>user</em>, but not a JavaScript
				<em>developer</em>.
			</p>
			<p>
				And then came node.js. JavaScript on the server, how cool
				is that?
			</p>
			<p>
				You decided that it's about time to check out the old, new
				JavaScript. But wait, writing node.js applications is the
				one thing; understanding why they need to be written the
				way they are written means - understanding JavaScript.
				And this time for real.
			</p>
			<p>
				Here is the problem: Because JavaScript really lives two,
				maybe even three lives (the funny little DHMTL helper from
				the mid-90's, the more serious frontend stuff like jQuery
				and the likes, and now server-side), it's not that easy to
				find information that helps you to learn JavaScript the
				"right" way, in order to write node.js applications in a
				fashion that makes you feel you are not just using
				JavaScript, you are actually developing it.
			</p>
			<p>
				Because that's the catch, you already are an experienced
				developer, you don't want to learn a new technique by just
				hacking around and mis-using it, you want to be sure that
				you are approaching it from the right angle.
			</p>
			<p>
				There is, of course, excellent documentation out there.
				But documentation alone	sometimes isn't enough. What is
				needed is guidance.
			</p>
			<p>
				My goal is to provide a guide for you.
			</p>

			<h3>A word of warning</h3>
			<p>
				There are some really excellent JavaScript people out
				there. I'm not one of them.
			</p>
			<p>
				I'm really just the guy I talked about in the previous
				paragraph. I know a thing or two about developing backend
				web applications, but I'm still new to "real" JavaScript
				and	still new to node.js. I learned some of the more
				advanced aspects of	JavaScript just recently.
				I'm not experienced.
			</p>
			<p>
				Which is why this is no "from novice to expert" book. It's
				more like "from novice to advanced novice".
			</p>
			<p>
				If I don't fail, then this here will be the kind of
				document I wish I had when starting with node.js.
			</p>

			<h3>Server-side JavaScript</h3>
			<p>
				The first incarnations of JavaScript lived in browsers.
				But this is just the context. It defines what you can
				do with the language, but it doesn't say much about what
				the language itself can do. JavaScript is a "complete"
				language, you can use it in many contexts and achieve
				everything with it you can achieve with any other
				"complete" language.
			</p>
			<p>
				node.js really is just another context: it allows to run
				JavaScript code in the backend, outside a browser.
			</p>
			<p>
				In order to execute the JavaScript you intend to run in the
				backend, it needs to be interpreted and, well, executed.
				This is what node.js does, by making use of Google's V8 VM, the
				same runtime environment for JavaScript that used in Google
				Chrome.
			</p>
			<p>
				Plus, node.js ships with a lot of useful modules, so you don't
				have to write everything from scratch, like for example
				something that outputs a string on the console.
			</p>
			<p>
				Thus, node.js is really two things: a runtime environment and a
				library.
			</p>
			<p>
				In order to make use of these, you need to install node.
				Instead of repeating the process here, I kindly ask you to
				visit
				<a href="https://github.com/joyent/node/wiki/Installation"
				   title="Building and Installing Node.js">the official
				installation instructions</a>. Please come back once you
				are up and running.
			</p>

			<h3>"Hello World"</h3>
			<p>
				Ok, let's just jump in the cold water and write our first
				node application: "Hello World".
			</p>
			<p>
				Open your favorite editor and create a file called
				<em>helloworld.js</em>. We want it to write "Hello World"
				to STDOUT, and here is the code needed to do that:
			</p>
			<p>
<pre class="prettyprint lang-js">console.log("Hello World");
</pre>
			</p>
			<p>
				Save the file, and execute it through node.js:
			</p>
			<p>
				<pre>node helloworld.js</pre>
			</p>
			<p>
				This should output <em>Hello World</em> on your terminal.
			</p>
			<p>
				Ok, this stuff is boring, right? Let's write some real
				stuff.
			</p>


			<h2>A full blown web application with node</h2>

			<h3>The use cases</h3>
			<p>
				Let's keep it simple, but realistic:
				<ul>
					<li>
						The user should be able to use our application with
						a web browser
					</li>
					<li>
						The user should see a welcome page when
						requesting http://<em>domain</em>/start
					</li>
					<li>
						When requesting http://<em>domain</em>/upload, the
						user should be able to upload an image file	from
						his computer, which is then displayed in his
						browser
					</li>
				</ul>
			</p>
			<p>
				Fair enough. Now, you could achieve this goal by googling
				and hacking together <em>something</em>. But that's not
				what we want to do here.
			</p>
			<p>
				Furthermore, we don't want to write only the most basic
				code to achieve the goal, how elegant and correct this code
				might be. We will intentionally add more abstraction than
				necessary in order to get a feeling for building more
				complex node applications.
			</p>

			<h3>The application stack</h3>
			<p>
				Let's dissect our application. Which parts need to be
				implemented in order to fulfill the use cases?

				<ul>
					<li>
						We want to serve web pages, therefore we need an
						<strong>HTTP server</strong>
					</li>
					<li>
						Our server will need to answer differently to
						requests, depending on which URL the request was
						asking for, thus we need some kind of
						<strong>router</strong> in order to map requests
						to request handlers
					</li>
					<li>
						To fullfill the requests that arrived at the server
						and have been routed using the router, we need
						actual <strong>request handlers</strong>
					</li>
					<li>
						The router probably should also treat any incoming
						POST data and give it to the request handlers in
						a convenient form, thus we need <strong>request
						data handling</strong>
					</li>
					<li>
						We not only want to handle requests for URLs, we
						also want to display content when these URLs are
						requested, which means we need some kind of
						<strong>view logic</strong> the request handlers
						can use in order to send content to the user's
						browser
					</li>
					<li>
						Last but not least, the user will be able to upload
						images, so we are going to need some kind of
						<strong>upload handling</strong> which takes care of
						the	details
					</li>
				</ul>
			</p>
			<p>
				Let's think a moment about how we would build this stack
				with PHP. It's not exactly a secret that the typical setup
				would be an Apache HTTP server with mod_php5 installed.
				<br/>
				Which in turn means that the whole "we need to be able to
				serve web pages and receive HTTP requests" stuff doesn't
				happen within PHP itself.
			</p>
			<p>
				Well, with node, things are a bit different. Because with
				node, we not only implement our application, we also
				implement the whole HTTP server. In fact, our web
				application	and its web server are basically the same.
			</p>
			<p>
				This might sound like a lot of work, but we will see in a
				moment that with node, it's not.
			</p>
			<p>
				Let's just start at the beginning and implement the first
				part of our stack, the HTTP server.
			</p>

			<h3>Building the application stack</h3>
			<h4>A basic HTTP server</h4>
			<p>
				When I arrived at the point where I wanted to start with my
				first "real" node application, I wondered not only how to
				actually code it, but also how to organize my code.
				<br/>
				Do I need to have everything in one file? Most tutorials on
				the web that teach you how to write a basic HTTP server in
				node have all the logic in one place. What if I want to
				make sure that my code stays readable the more stuff I
				implement?
			</p>
			<p>
				Turns out, it's relatively easy to keep the different
				concerns of your code separated, by putting them in
				modules.
			</p>
			<p>
				This allows you to have a clean main file, which you
				execute with node, and clean modules that can be used by
				the main file and among each other.
			</p>
			<p>
				So, let's create a main file which we use to start our
				application, and a module file where our HTTP server code
				lives.
			</p>
			<p>
				My impression is that it's more or less a standard to name
				your main file <em>index.js</em>. It makes sense to put	our
				server module into a file named <em>server.js</em>.
			</p>
			<p>
				Let's start with the server module. Create the file
				<em>server.js</em> in the root directory of your project,
				and fill it with the following code:
			</p>
			<p>
<pre class="prettyprint lang-js">var http = require("http");

http.createServer(function(request, response) {
  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("Hello World");
  response.end();
}).listen(8888);
</pre>
			</p>
			<p>
				That's it! You just wrote a working HTTP server. Let's
				prove it by running and testing it. First, execute your
				script with node:
			</p>
			<p>
				<pre>node server.js</pre>
			</p>
			<p>
				Now, open your browser and point it at
				<a href="http://localhost:8888/">http://localhost:8888/</a>.
				This should display a web page that says "Hello World".
			</p>
			<p>
				That's quite interesting, isn't it. How about talking about
				what's going on here and leaving the question of how to
				organize our project for later? I promise we'll get back to
				it.
			</p>

			<h4>Analyzing our HTTP server</h4>
			<p>
				Well, then, let's analyze what's actually going on here.
			</p>
			<p>
				The first line <em>require</em>s the <em>http</em> module
				that ships with node and makes it accessible through the
				variable <em>http</em>.
			</p>
			<p>
				We then call one of the functions the http module offers:
				<em>createServer</em>. This function returns an object, and
				this object has a method named <em>listen</em>, and takes
				a numeric value which indicates the port number our HTTP
				server is going to listen on.
			</p>
			<p>
				Please ignore for a second the function definition that
				follows the opening bracket of <em>http.createServer</em>.
			</p>
			<p>
				We could have written the code that starts our server and
				makes it listen at port 8888 like this:
			</p>
			<p>
<pre class="prettyprint lang-js">var http = require("http");

var server = http.createServer();
server.listen(8888);</pre>
			</p>
			<p>
				That would start an HTTP server listening at port 8888
				and doing nothing else (not even answering any incoming
				requests).
			</p>
			<p>
				The really interesting (and, if your background is a more
				conservative language like PHP, odd looking) part is the
				function definition right there where you would expect the
				first parameter of the <em>createServer()</em> call.
			</p>
			<p>
				Turns out, this function definition IS the first (and only)
				parameter we are giving to the <em>createServer()</em>
				call. Because in JavaScript, functions can be passed around
				like any other value.
			</p>

			<h4>Passing functions around</h4>
			<p>
				You can, for example, do something like this:
			</p>
			<p>
<pre class="prettyprint lang-js">function say(word) {
  console.log(word);
}

function execute(someFunction, value) {
  someFunction(value);
}

execute(say, "Hello");</pre>
			</p>
			<p>
				Read this carefully! What we are doing here is, we pass the
				function <em>say</em> as the first parameter to the
				<em>execute</em> function. Not the return value of
				<em>say</em>, but <em>say</em> itself!
			</p>
			<p>
				Thus, <em>say</em> becomes the local variable
				<em>someFunction</em> within <em>execute</em>, and execute
				can call the function in this variable by issuing
				<em>someFunction()</em> (adding brackets).
			</p>
			<p>
				Of course, because <em>say</em> takes one parameter,
				<em>execute</em> can pass such a parameter when calling
				<em>someFunction</em>.
			</p>
			<p>
				We can, as we just did, pass a function as a parameter to
				another function by it name. But we don't have to take this
				indirection of first defining, then passing it - we can
				define and pass a function as a parameter to another
				function in-place:
			</p>
			<p>
<pre class="prettyprint lang-js">function execute(someFunction, value) {
  someFunction(value);
}

execute(function(word){ console.log(word) }, "Hello");
</pre>
			</p>
			<p>
				We define the function we want to pass to <em>execute</em>
				right there at the place where <em>execute</em> expects its
				first parameter.
			</p>
			<p>
				This way, we don't even need to give the function a name,
				which is why this is called an <em>anonymous function</em>.
			</p>
			<p>
				This is a first glimpse at what I like to call "advanced"
				JavaScript, but let's take it step by step. For now, let's
				just accept that in JavaScript, we can pass a function as
				a parameter when calling another function. We can do this
				by assigning our function to a variable, which we then
				pass, or by defining the function to pass in-place.
			</p>

			<h4>How function passing makes our HTTP server work</h4>
			<p>
				With this knowledge, let's get back to our minimalistic
				HTTP server:
			</p>
			<p>
<pre class="prettyprint lang-js">var http = require("http");

http.createServer(function(request, response) {
  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("Hello World");
  response.end();
}).listen(8888);
</pre>
			</p>
			<p>
				By now it should be clear what we are actually doing here:
				we pass the <em>createServer</em> function an anonymous
				function.
			</p>
			<p>
				We could achieve the same by refactoring our code to:
			</p>
			<p>
<pre class="prettyprint lang-js">var http = require("http");

function onRequest(request, response) {
  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("Hello World");
  response.end();
}

http.createServer(onRequest).listen(8888);
</pre>
			</p>
			<p>
				Maybe now is a good moment to ask: Why are we doing it
				that way?
			</p>

			<h4>Event-driven callbacks</h4>
			<p>
				The answer is a) not that easy to give (at least for me), and
				b) lies in the very nature of how node works. It's
				event-driven, which is the reason why it's so fast.
			</p>
			<p>
				You might want to take the time to read Felix
				Geisendörfer's excellent post
				<a href="http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb">Understanding node.js</a>
				for some background explanation.
			</p>
			<p>
				It all boils down to the fact that node works event-driven.
				Oh and yes, I, too, don't know exactly what that means.
				But I will try and explain, why this makes sense for us
				who want to write web based applications in node.
			</p>
			<p>
				When we call the <em>http.createServer</em> method, we
				of course not only want to have a server listening at
				some port, we also want to do something when there is an
				HTTP request to this server.
			</p>
			<p>
				The problem is, this happens asynchronously: it happens
				at any given time, but we only have a single process in
				which our server runs.
			</p>
			<p>
				When writing PHP applications, we aren't bothered by this
				at all: whenever there is an incoming HTTP request, the
				webserver (usually Apache) forks a new process for just
				this request, and starts the according PHP script from
				scratch, which is then executed from top to bottom.
			</p>
			<p>
				So in regards of control flow, we are in the midst of our
				node program when a new request arrives at port 8888 - how
				to handle this without going insane?
			</p>
			<p>
				Well, this is where the event-driven design of
				node/JavaScript actually helps, although we need to learn
				some new concepts in order to master it. Let's see how
				these concepts are applied in our server code.
			</p>
			<p>
				We create the server, and pass a function to the method
				creating it. Whenever our server receives a request, the
				function we passed will be called.
			</p>
			<p>
				We don't know when this is going to happen, but we now have
				a place where we can handle an incoming request. It's our
				passed function, no matter if we first defined it or passed
				it anonymously.
			</p>
			<p>
				This concept is called a <em>callback</em>. We pass into
				some method a function, and the method uses this function
				to <em>call back</em> if an event related to the method
				occurs.
			</p>
			<p>
				At least for me, this took some time to understand. Just
				read Felix' blog post again if you are still unsure.
			</p>
			<p>
				Let's play around a bit with this new concept. Can we prove
				that our code continues after creating the server, even if
				no HTTP request happened and the callback function we
				passed isn't called? Let's try it:
			</p>
			<p>
<pre class="prettyprint lang-js">var http = require("http");

function onRequest(request, response) {
  console.log("Request received.");
  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("Hello World");
  response.end();
}

http.createServer(onRequest).listen(8888);

console.log("Server has started.");
</pre>
			</p>
			<p>
				Note that I use <em>console.log</em> to	output a text whenever
				the <em>onRequest</em> function (our callback) is triggered,
				and	another text right <em>after</em> starting the HTTP server.
			</p>
			<p>
				When we start this (<em>node server.js</em>, as always), it
				will immediately output "Server has started." on the
				command line. Whenever we request our server (by opening
				<a href="http://localhost:8888/">http://localhost:8888/</a>
				in our browser), the message "Request received." is printed
				on the command line.
			</p>
			<p>
				Event-driven asynchronous server-side JavaScript with
				callbacks in action :-)
			</p>
			<p>
				(Note that our server will probably write "Requested received."
				to STDOUT two times upon opening the page in a browser. That's
				because most browser will try to load the favicon by requesting
				http://localhost:8888/favicon.ico whenever you open
				http://localhost:8888/).
			</p>

			<h4>How our server handles requests</h4>
			<p>
				Ok, let's quickly analyze the rest of our server code, that
				is, the body of our callback function <em>onRequest()</em>.
			</p>
			<p>
				When the callback fires and our <em>onRequest()</em> function
				gets triggered, two parameters are passed into it:
				<em>request</em> and <em>response</em>.
			</p>
			<p>
				Those are objects, and you can use their methods to handle
				the	details of the HTTP request that occured and to respond
				to the request (i.e., to actually send something over
				the wire back to the browser that requested your server).
			</p>
			<p>
				And our code does just that: Whenever a request is
				received, it uses the <em>response.writeHead()</em>
				function to send an HTTP status 200 and content-type in the
				HTTP response header, and the <em>response.write()</em>
				function to send the text "Hello World" in the HTTP
				response body.
			</p>
			<p>
				At last, we call <em>response.end()</em> to actually finish
				our response.
			</p>
			<p>
				At this point, we don't care for the details of the
				request, which is why we don't use the <em>request</em>
				object at all.
			</p>


			<h4>Finding a place for our server module</h4>
			<p>
				Ok, I promised we will get back to how to organize our
				application. We have the code for a very basic HTTP server in
				the file <em>server.js</em>, and I mentioned that it's common
				to have a main file called <em>index.js</em> which is used
				to bootstrap and start our application by making use of the
				other modules of the application (like the HTTP server module
				that lives in <em>server.js</em>).
			</p>
			<p>
				Let's talk about how to make server.js a real node module
				that can be used by our yet to write index.js main file.
			</p>
			<p>
				As you may have noticed, we already used modules in our code,
				like this:
			</p>
			<p>
<pre class="prettyprint lang-js">var http = require("http");

...

http.createServer(...);
</pre>
			</p>
			<p>
				Somewhere within node lives a module called "http", and we can
				make use of it in our own code by requiring it and assigning
				the result of the require to local variable.
			</p>
			<p>
				This makes our local variable an object that carries all the
				public methods the <em>http</em> module provides.
			</p>
			<p>
				It's common practice to choose the name of the module for the
				name of the local variable, but we are free to choose whatever
				we like:
			</p>
			<p>
<pre class="prettyprint lang-js">var foo = require("http");

...

foo.createServer(...);
</pre>
			</p>
			<p>
				Fine, it's clear how to make use of internal node modules. How
				do we create our own modules, and how do we use them?
			</p>
			<p>
				Let's find out by turning our <em>server.js</em> script into a
				real module.
			</p>
			<p>
				Turns out, we don't have to change that much. Making some code
				a module means we need to <em>export</em> those parts of its
				functionality that we want to provide to scripts that require
				our module.
			</p>
			<p>
				For now, the functionality our HTTP server needs to export is
				simple: scripts requiring our server module simply need to
				start the server.
			</p>
			<p>
				To make this possible, we will put our server code into a
				function named <em>start</em>, and we will export this
				function:
			</p>
			<p>
<pre class="prettyprint lang-js">var http = require("http");

function start() {
  function onRequest(request, response) {
    console.log("Request received.");
    response.writeHead(200, {"Content-Type": "text/html"});
    response.write("Hello World");
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("Server has started.");
}

exports.start = start;
</pre>
			</p>
			<p>
				This way, we can now create our main file <em>index.js</em>,
				and start our HTTP there, although the code for the server is
				still in our <em>server.js</em> file.
			</p>
			<p>
				Create a file <em>index.js</em> with the following content:
			</p>
			<p>
<pre class="prettyprint lang-js">var server = require("./server");

server.start();
</pre>
			</p>
			<p>
				As you can see, we can use our server module just like any
				internal module: by requiring its file and assigning it to
				a variable, its exported functions become available to us.
			</p>
			<p>
				That's it. We can now start our app via our main script, and it
				still does exactly the same:
			</p>
			<p>
<pre>
node index.js
</pre>
			</p>
			<p>
				Great, we now can put the different parts of our application
				into different files and wire them together by making them
				modules.
			</p>
			<p>
				We still have only the very first part of our application in
				place: we can receive HTTP requests. But we need to do
				something with them - depending on which URL the browser
				requested from our server, we need to react differently.
			</p>
			<p>
				For a very simple application, you could do this directly
				within the callback function <em>onRequest()</em>. But as I said,
				let's add a bit more abstraction in order to make our example
				application a bit more interesting.
			</p>
			<p>
				Making different HTTP requests point at different parts of our
				code is called "routing" - well, then, let's create a module
				called <em>router</em>.
			</p>

			<h4>What's needed to "route" requests?</h4>
			<p>
				We need to be able to feed the requested URL and possible
				additional GET and POST parameters into our router, and based
				on these the router then needs to be able to decide which code
				to execute (this "code to execute" is the third part of our
				application: a collection of request handlers that do the
				actual work when a request is received).
			</p>
			<p>
				So, we need to look into the HTTP requests and extract the
				requested URL as well as the GET/POST parameters from them.
				It could be argued if that should be part of the router or
				part of the server (or even a module of its own), but let's
				just agree on making it part of our HTTP server for now.
			</p>
			<p>
				All the information we need is available through the
				<em>request</em> object which is passed as the first parameter
				to our callback function <em>onRequest()</em>. But to interpret
				this information, we need some additional node modules, namely
				<em>url</em> and <em>querystring</em>.
			</p>
			<p>
				The <em>url</em> module provides methods which allow us to
				extract the different parts of a URL (like e.g. the requested
				path and query string), and <em>querystring</em> can in turn be
				used to parse the query string for request parameters:
			</p>
<pre>
                    url.path     url.query
                       |            |
                       |            |
                     ------ -------------------
http://localhost:8888/start?foo=bar&hello=world
                                ---       -----
                                 |          |
                                 |          |
            querystring(url.query)["foo"]   |
                                            |
                       querystring(url.query)["hello"]

</pre>
			<p>
				We can, of course, also use <em>querystring</em> to parse the
				body of a POST request body for parameters, as we will see
				later.
			</p>
			<p>
				Let's now add to our <em>onRequest()</em> function the logic
				needed to find out which URL path the browser requested:
			</p>
			<p>
<pre class="prettyprint lang-js">var http = require("http");
var url = require("url");

function start() {
  function onRequest(request, response) {
	var pathname = url.parse(request.url).pathname;
	console.log("Request for " + pathname + " received.");
	response.writeHead(200, {"Content-Type": "text/html"});
	response.write("Hello World");
	response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("Server has started.");
}

exports.start = start;
</pre>
			</p>
			<p>
				Fine. Our application can now distinguish requests based on the
				URL path requested - this allows us to map requests to our
				request handlers based on the URL path using our (yet to be
				written) router. Thus, we can build our application in a
				RESTful way, because we can now implement an interface that
				follows the guiding principle of <em>Identification of
				resources</em> (see
				<a href="http://en.wikipedia.org/wiki/Representational_State_Transfer#Guiding_principles_of_the_interface">the Representational State Transfer article on Wikipedia</a>
				for background information).
			</p>
			<p>
				In the context of our application, it simply means that we will
				be able to have requests for the <em>/start</em> and
				<em>/upload</em> URLs handled by different parts of our
				code. We will see how everything fits together soon.
			</p>
			<p>
				Ok, it's time to actually write our router. Create a new file
				called <em>router.js</em>, with the following content:
			</p>
			<p>
<pre class="prettyprint lang-js">function route(pathname) {
  console.log("About to route a request for " + pathname);
}

exports.route = route;
</pre>
			</p>
			<p>
				Of course, this code basically does nothing, but that's ok for
				now. Let's first see how to wire together this router with our
				server before putting more logic into the router.
			</p>
			<p>
				Our HTTP server needs to know about and make use of our router.
				We could hard-wire this dependency into the server, but because
				we learned the hard way from our experience with other
				programming languages, we are going to loosely couple server
				and router by injection this dependency (you may want to read
				<a href="http://martinfowler.com/articles/injection.html">Martin Fowlers excellent post on Dependency Injection</a>
				for	background information).
			</p>
			<p>
				Let's first extend our server's <em>start()</em> function in
				order to enable us to pass the route function to be used by
				parameter:
			</p>
			<p>
<pre class="prettyprint lang-js">var http = require("http");
var url = require("url");

function start(route) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log("Request for " + pathname + " received.");

    route(pathname);

    response.writeHead(200, {"Content-Type": "text/html"});
    response.write("Hello World");
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("Server has started.");
}

exports.start = start;
</pre>
			</p>
			<p>
				And let's extend our <em>index.js</em> accordingly, that is,
				injecting the route function of our router into the server:
			</p>
			<p>
<pre class="prettyprint lang-js">var server = require("./server");
var router = require("./router");

server.start(router.route);

</pre>
			</p>
			<p>
				Again, we are passing a function, which by now isn't any news
				for us.
			</p>
			<p>
				If we start our application now (<em>node index.js,
				as always</em>), and request an URL, you can now see from the
				application's output that our HTTP server makes use of our
				router and passes it the requested pathname:
			</p>
			<p>
<pre>bash$ node index.js
Request for /foo received.
About to route a request for /foo
</pre>
			</p>
			<p>
				(I omitted the rather annoying output for the /favicon.ico
				request).
			</p>

			<h4>Execution in the kingdom of verbs</h4>
			<p>
				May I once again stray away for a while and talk about
				functional programming again?
			</p>
			<p>
				Passing functions is not only a technical consideration.
				In regards of software design, it's almost philosophical.
				Just think about it: in our index file, we could have passed
				the	<em>router</em> object into the server, and the server
				could have called this object's <em>route</em> function.
			</p>
			<p>
				This way, we would have passed a <em>thing</em>, and the server
				would have used this thing to <em>do</em> something. Hey,
				router thing, could you please route this for me?
			</p>
			<p>
				But the server doesn't need the thing. It only needs to get
				something <em>done</em>, and to get something done, you don't
				need things at all, you need <em>actions</em>. You don't need
				<em>nouns</em>, you need <em>verbs</em>.
			</p>
			<p>
				Understanding the fundamental mind-shift that's at the core of
				this idea is what made me really understand functional
				programming.
			</p>
			<p>
				And I did understand it when reading Steve Yegge's masterpiece
				<a href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html">Execution in the Kingdom of Nouns</a>.
				Go read it now, really. It's one of the best writings related
				to software I ever had the pleasure to encounter.
			</p>

			<a name="routing-to-real-request-handlers" />
			<h4>Routing to real request handlers</h4>
			<p>
				Back to business. Our HTTP server and our request router are
				now best friends and talk to each other as we intended.
			</p>
			<p>
				Of course, that's not enough. "Routing" means, we want to
				handle requests to different URLs differently. We would like to
				have the "business logic" for requests to <em>/start</em>
				handled in another function than requests to <em>/upload</em>.
			</p>
			<p>
				Right now, the routing "ends" in the router, and the router is
				not the place to actually "do" something with the requests,
				because that wouldn't scale well once our application becomes
				more complex.
			</p>
			<p>
				Let's call these functions, where requests are routed to,
				<em>request handlers</em>. And let's tackle those next, because
				unless we have these in place there isn't much sense in doing
				anything with the router for now.
			</p>
			<p>
				New application part, new module - no surprise here. Let's
				create a module called requestHandlers, add a placeholder
				function for every request handler, and export these as
				methods of the module:
			</p>
			<p>
<pre class="prettyprint lang-js">function start() {
  console.log("Request handler 'start' was called.");
}

function upload() {
  console.log("Request handler 'upload' was called.");
}

exports.start = start;
exports.upload = upload;
</pre>
			</p>
			<p>
				This allows us to wire the request handlers into the router,
				giving our router something to route to.
			</p>
			<p>
				At this point we need to make a decision: do we hard-code usage
				of the requestHandlers module into the router, or do we want a
				bit more dependency injection? Although dependency injection,
				like every other pattern, shouldn't be used only for the sake
				of using it, in this case it makes sense to loosely couple the
				router and its request handlers, and thus making the router
				really reusable.
			</p>
			<p>
				This means we need to pass the request handlers from our server
				into our router, but this feels even more wrong, which is why
				we should go the whole way and pass them to the server from	our
				main file, and passing it on to the router from there.
			</p>
			<p>
				How are we going to pass them? Right now we have two handlers,
				but in a real application, this number is going to increase and
				vary, and we sure don't want to fiddle around mapping requests
				to handlers in the router anytime a new URL / request handler
				is added. And having some
				<em>if request == x then call handler y</em> in the router
				would be more than ugly.
			</p>
			<p>
				A varying number of items, each mapped to a string (the
				requested URL)? Well, sounds like an associative array would be
				a perfect fit.
			</p>
			<p>
				Well, this finding is slightly disappointed by the fact that
				JavaScript doesn't provide associative array - or does it?
				Turns out, it's actually objects that we want to use if we need
				an associative array!
			</p>
			<p>
				There's a nice introduction to this at
				<a href="http://msdn.microsoft.com/en-us/magazine/cc163419.aspx">http://msdn.microsoft.com/en-us/magazine/cc163419.aspx</a>,
				let me quote the relevant part:
			</p>
			<p>
				<blockquote>
					In C++ or C#, when we’re talking about objects, we're
					referring to instances of classes or structs. Objects have
					different properties and methods, depending on which
					templates (that is, classes) they are instantiated from.
					That's not the case with JavaScript objects. In JavaScript,
					objects are just collections of name/value pairs - think of a
					JavaScript object as a dictionary with string keys.
				</blockquote>
			</p>
			<p>
				If JavaScript objects are just collections of name/value pairs,
				how can they have methods? Well, the values can be strings,
				numbers etc. - or functions!
			</p>
			<p>
				Ok, now finally back to the code. We decided we want to pass
				the list of requestHandlers as an object, and in order to
				achieve loose coupling we want to inject this object into the
				<em>>route()</em>.
			</p>
			<p>
				Let's start with putting the object together in our main file
				<em>index.js</em>:
			</p>
			<p>
<pre class="prettyprint lang-js">var server = require("./server");
var router = require("./router");
var requestHandlers = require("./requestHandlers");

var handle = {}
handle["/"] = requestHandlers.start;
handle["/start"] = requestHandlers.start;
handle["/upload"] = requestHandlers.upload;

server.start(router.route, handle);
</pre>
			</p>
			<p>
				Although <em>handle</em> is more of a "thing" (a collection of
				request handlers), I propose we name it like a verb, because
				this will result in a fluent expression in our router, as we
				will see soon.
			</p>
			<p>
				As you can see, it's really simple to map different URLs to the
				same request handler: by adding a key/value pair of
				<em>"/"</em> and <em>requestHandlers.start</em>, we can express
				in a nice and clean way that not only requests to
				<em>/start</em>, but also requests to <em>/</em> shall be
				handled by the <em>start</em> handler.
			</p>
			<p>
				After defining our object, we pass it into the server as an
				additional parameter. Let's change our <em>server.js</em> to
				make use of	it:
			</p>
			<p>
<pre class="prettyprint lang-js">var http = require("http");
var url = require("url");

function start(route, handle) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log("Request for " + pathname + " received.");

    route(handle, pathname);

    response.writeHead(200, {"Content-Type": "text/html"});
    response.write("Hello World");
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("Server has started.");
}

exports.start = start;
</pre>
			</p>
			<p>
				We've added the <em>handle</em> parameter to our
				<em>start()</em> function, and pass the handle object on to
				the <em>route()</em> callback, as its first parameter.
			</p>
			<p>
				Let's change the <em>route()</em> function accordingly, in our
				<em>router.js</em> file:
			</p>
			<p>
<pre class="prettyprint lang-js">function route(handle, pathname) {
  console.log("About to route a request for " + pathname);
  if (handle[pathname] != undefined) {
	  handle[pathname]();
  } else {
	  console.log("No request handler found for " + pathname);
  }
}

exports.route = route;
</pre>
			</p>
			<p>
				We we do here is, we check if a request handler for the given
				pathname exists, and if it does, we simply call the according
				function. Because we can access our request handler functions
				from our object just as we would access an element of an
				associative array, we have this nice fluent
				<em>handle[pathname]();</em> expression I talked about earlier:
				"Please, <em>handle</em> this <em>pathname</em>".
			</p>
			<p>
				Ok, that's all we need to wire server, router, and request
				handlers together! When starting our application and requesting
				<a href="http://localhost:8888/start">http://localhost:8888/start</a>
				in our browser, we can prove that the correct request handler
				was indeed called:
			</p>
			<p>
<pre>Server has started.
Request for /start received.
About to route a request for /start
Request handler 'start' was called.
</pre>
			</p>
			<p>
				And opening <a href="http://localhost:8888/">http://localhost:8888/</a>
				in our browser proves that these requests, too, are indeed handled by
				the <em>start</em> request handler:
			</p>
			<p>
<pre>Request for / received.
About to route a request for /
Request handler 'start' was called.
</pre>
			</p>










			<p id="workinprogressnote">
				The Node Beginner Book is work-in-progress.
				<br />
				It's currently about 40% done.
				<br />
				Check back daily to see the latest version.
				<br />
				<br />
				The version you are	currently reading was updated on
				<br />
				Wednesday, April 19, 2011 at 7:57 AM EDT.
			</p>


		</div>









		<div id="disqus_thread"></div>
		<script type="text/javascript">
			var disqus_shortname = 'nodebeginner';
			var disqus_identifier = 'nodebeginner-book';
			var disqus_url = 'http://www.nodebeginner.org/';

			(function() {
				var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
				dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
				(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
			})();
		</script>
		<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

		<div id="footer">
			<p id="ccimage">
				<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a>
			</p>
			<p>
				<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">The Node Beginner Book</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="http://manuel.kiessling.net" property="cc:attributionName" rel="cc:attributionURL">Manuel Kiessling</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.
				<br />
				Permissions beyond the scope of this license may be available at <a xmlns:cc="http://creativecommons.org/ns#" href="mailto:manuel@kiessling.net" rel="cc:morePermissions">manuel@kiessling.net</a>.
			</p>
		</div>
	</body>
</html>
