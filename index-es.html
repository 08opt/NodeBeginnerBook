<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link href="prettify/prettify.css" type="text/css" rel="stylesheet" />

		<title>El Libro de Node.js para el Principiante» Un tutorial completo de node.js</title>
		<meta name="description" content="Un tutorial completo de Node.js para principiantes: Aprende como construir una aplicación web completa con Javascript del lado del servidor" />

		<style type="text/css">
			body {
				font-family: Georgia, serif;
				background-color: #eee;
				padding-top: 48px;
				-webkit-text-size-adjust: 200%;
			}

			#book, #donate, #disqus_thread, #footer, #workinprogressnote {
				width: 640px;
				margin: 0 auto;
				margin-top: 24px;
				margin-bottom: 100px;
				padding: 64px;
				background-color: white;
				border-top: 1px solid #ddd;
				border-left: 1px solid #ddd;
				border-bottom: 1px solid #ddd;
				border-right: 1px solid #ddd;
				z-index: 100;

				-moz-box-shadow: 14px 11px 27px #888;
				-webkit-box-shadow: 14px 11px 27px #888;
				box-shadow: 14px 11px 27px #888;
			}

			#author {
				margin-top: -20px;
				margin-left: 250px;
				color: #888;
				font-family: "Helvetica Neue", sans-serif;
				font-size: 75%;
			}

			#updateinfo {
				margin-top: 20px;
				margin-left: 250px;
				color: #bbb;
				font-family: "Helvetica Neue", sans-serif;
				font-size: 75%;
			}

			#workinprogressnote p {
				font-family: "Helvetica Neue", sans-serif;
				color: #700;
				text-align: center;
			}

			#donate p {
				font-family: "Helvetica Neue", sans-serif;
				text-align: center;
			}

			#flattr {
				padding-top: 20px;
				margin-left: 183px;
				margin-right: 18px;
				text-align: center;
				align: left;
				display: inline-block;
				width: 100px;
			}

			#paypal {
				display: inline-block;
				margin-top: 24px;
				text-align: center;
				vertical-align: top;
			}

			#paypal fieldset {
				border: 0;
			}

			#disqus_thread {
				font-family: "Helvetica Neue", sans-serif;
			}

			#footer {
				font-family: "Helvetica Neue", sans-serif;
				background-color: #f5f5f5;
				margin-top: 100px;
			}

			#footer p {
				text-align: center;
				font-family: "Helvetica Neue", sans-serif;
				font-size: 11px;
			}

			#ccimage {
				float: left;
				margin-left: 30px;
				margin-right: 0;
				margin-top: 20px;
				margin-bottom: 50px;
			}

			#praise {
				position: absolute;
				top: 120px;
				right: 40px;
				width: 204px;
				font-style: italic;
				color: #aaa;
				z-index: -1;
				text-align: right;
			}

			#praise .praise {
				margin-bottom: 25px;
			}

			#praise .author {
				font-style: normal;
				font-size: 75%;
			}

			#table-of-contents-headline {
				margin-top: 48px;
				color: #700;
				font-size: 160%;
				font-weight: bold;
			}

			#book #table-of-contents {
				margin-left: -24px;
			}

			#book #table-of-contents ul li {
				font-size: 100%;
				margin-left: 0;
				list-style-type: none;
			}

			#book #table-of-contents ul {
				padding-left: 24px;
				margin-top: 12px;
				margin-left: 0;
				margin-bottom: 36px;
			}

			h1 {
				margin-left: -50px;
				margin-top: -50px;
				font-size: 300%;
				color: #444;
				font-style: italic;
    			font-weight: bold;
				-webkit-text-size-adjust: 100%;
			}

			h2 {
				margin-top: 64px;
				font-size: 180%;
			}

			h3 {
				font-size: 160%;
			}

			h4 {
				font-size: 140%;
			}

			h5 {
				font-size: 120%;
			}

			h3, h4, h5 {
				margin-top: 36px;
			}

			h2, h3, h4, h5 {
				color: #700;
				font-weight: bold;
				margin-bottom: 36px;
			}

			#book p {
				text-align: justify;
				font-size: 110%;
				line-height: 150%;
				margin-bottom: 48px;
    			margin-top: -22px;
			}

			pre {
				background-color: #f7f7f7;
				border: 1px solid #eee;
				padding: 16px;
				margin-bottom: 64px;
				margin-top: -24px;
				font-size: 14px;
			}

			pre.prettyprint {
				background-color: #f7f7f7;
				border: 1px solid #eee;
				padding: 16px;
				margin-bottom: 64px;
				margin-top: -24px;
				font-size: 14px;
			}

			#book ul {
				margin-top: -24px;
				margin-bottom: 64px;
			}

			ul li {
				margin-bottom: 12px;
				font-size: 110%;
			}

			blockquote {
				font-style: italic;
			}
		</style>
		<style type="text/css" media="print">
			#forkmeongithub {
				display: none;
			}
			#praise {
				display: none;
			}
		</style>

		<script type="text/javascript" src="mootools-core-1.3.1-full-compat-yc.js"></script>
 		<script type="text/javascript" src="TOC.js"></script>
		<script type="text/javascript">
			window.addEvent('domready', function() {
    			var toc = new TOC('table-of-contents');
			});
		</script>
		<script type="text/javascript" src="prettify/prettify.js"></script>
		<script type="text/javascript">
			var _gaq = _gaq || [];
			_gaq.push(['_setAccount', 'UA-2127388-6']);
			_gaq.push(['_trackPageview']);

			(function() {
				var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
				ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
				var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
			})();
		</script>
		<script type="text/javascript">
		/* <![CDATA[ */
			(function() {
				var s = document.createElement('script'), t = document.getElementsByTagName('script')[0];
				s.type = 'text/javascript';
				s.async = true;
				s.src = 'http://api.flattr.com/js/0.6/load.js?mode=auto';
				t.parentNode.insertBefore(s, t);
			})();
		/* ]]> */
		</script>
	</head>
	<body onload="prettyPrint();">
		<div id="forkmeongithub">
			<a href="https://github.com/ManuelKiessling/NodeBeginnerBook"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://d3nwyuy0nl342s.cloudfront.net/img/71eeaab9d563c2b3c590319b398dd35683265e85/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" /></a>
		</div>

		<div id="book">
			<h1>El Libro para Principiantes en Node.js</h1>
			<div id="author">Un tutorial de Node.js por:<a href="http://twitter.com/manuelkiessling">Manuel Kiessling</a></div>
			<div id="updateinfo">&#218;ltima actualizaci&oacute;n el Domingo 24 de Abril, 2011 a las 6:52 AM EDT</div>
                        <div id="updateinfo">&#218;ltima traducci&oacute;n el Martes 03 de Mayo, 2011 a las 01.11 AM EDT</div>

			<h2>Sobre el Tutorial</h2>

			<p>
				
				El objetivo de este documento es ayudarte a empezar con el
				desarrollo de aplicaciones para Node.js, enseñándote todo lo 
				que necesites saber acerca de Javascript "avanzado" sobre
				la marcha. Este tutorial va mucho más allá del típico manual
				"Hola Mundo".

			</p>
			<p>
				Este documento todavía está siendo escrito y va terminado
				en un 80%.
			</p>

			<h3>Audiencia Objetivo</h3>
			<p>
				Este documento probablemente será mejor entendido por los
				lectores que tengan un trasfondo similar al mío: Programadores
				experimientados en al menos un lenguaje orientado al objeto,
				como Ruby, Python, PHP o Java; poca experiencia con JavaScript, y
				ninguna experiencia en Node.js.
			</p>
			<p>
				El que este documento esté orientado a desarrolladores 
				que ya tienen experiencia con otros lenguajes
				de programación significa que no vamos a cubrir temas 
				realmente básicos como tipos de datos, variables, estructuras
				de control y similares. Se debe saber acerca de estos tópicos
				para entender este documento.
				
			</p>
			<p>
				Sin embargo, dado que las funciones y objetos en JavaScript
				son diferentes de sus contrapartes en la mayoria de los lenguajes,
				estos serán explicados con más detalle.
			</p>

			<h3>Estructura de este documento</h3>
			<p>
				Al Término de este documento, Tú habrás creado una aplicación
				Web completa, que permita a los usuarios de ésta el ver
				páginas web y subir archivos.
			</p>
			<p>
				La cual, por supuesto, no va ser nada como la "aplicación que
				va a cambiar el mundo", no obstente eso, nosotros haremos la
				milla extra y no vamos sólo a codificar una aplicación lo
				"suficientemente simple" para hacer estos casos de uso posible,
				sino que crearemos un framewoirk sencillo, pero completo, a fin de 
				poder separar los distintos aspectos de nuestra aplicación.
				Verás lo que esto significa en poco tiempo.
			</p>
			<p>
				Empezaremos por mirar cómo el desarrollo en JavaScript en Node.js
				es diferente del desarrollo en JavaScript en un browser.
			</p>
			<p>
				Luego, nos mantendremos con la vieja tradición de escribir una
				aplicación "Hola Mundo", la cual es la aplicación más básica
				de Node.js que "hace" algo.
			</p>
			<p>
				Enseguida, discutiremos que tipo de "aplicación del mundo real"
				queremos construir, disectaremos las diferentes partes que necesitan
				ser implementadas para ensamblar esta aplicación, y empezaremos
				trabajando en cada una de estas partes paso a paso.
			</p>
			<p>
				Tal y cual lo prometido, aprenderemos sobre la marcha acerca
				de algunos de los muchos conceptos avanzados de JavaScript,
				como hacer uso de ellos, y ver el porqué tiene sentido el hacer
				uso de estos conceptos en vez de los que ya conocemos por
				otros lenguajes de programación.
			</p>

			<div id="table-of-contents-headline">Tabla de Contenidos</div>
			<div id="table-of-contents"></div>

			<h2>JavaScript y Node.js</h2>

			<h3>JavaScript y Tú</h3>
			<p>
				Antes que hablemos de toda la parte técnica, tomémosnos
				un minuto y hablemos acerca de tí y tu relación con 
				JavaScript. Este capitulo está aquí para permitirte estimar
				si tiene sentido el que sigas o no leyendo este documento.
			</p>
			<p>
				Si tú eres como yo, empezaste con el "desarrollo" HTML
				hace bastante tiempo, escribiendo documentos HTML. Te 
				encontraste en el camino con esta cosa divertida llamada
				JavaScript, pero solo la usabas en una forma muy básica,
				agregando interactividad a tus páginas de cuando en cuando.
			</p>
			<p>
				Lo que Tú realmente querías era "la cosa real", Tú querías
				saber como construir sitios web comlejos - Tú aprendiste un
				lenguaje de programación como PHP, Ruby, Java, y empezaste a 
				escribir codigo "backend".
			</p>
			<p>
				No obstante tú mantuviste un ojo en JavaScript, y te diste
				cuenta que con la introducción de jQuery, Prototype y otros,
				las cosas se fueron poniendo más avanzadas en las Tierras
				de JavaScript, y que este lenguaje era realmente más que
				<em>window.open()</em>.							
			</p>
			<p>
				Sin embargo, esto era todo cosa del 
				<span style="font-style: italic;">frontend</span> ,y aunque era
				agradable contar con jQuery a tu disposición en cualquier
				momento que te sintieras con animo de sazonar una página web,
				al final del día, tu eras a lo más, un usuario de JavaScript,
				pero no, un desarrollador de JavaScript.
			</p>
			<p>
				Y entonces llegó Node.js. JavaScript en el servidor, ¿Qué
				hay con eso?				
			</p>
			<p>
				Decidiste que era ya tiempo de revisar el nuevo JavaScript.
				Pero espera: Escribir aplicaciones Node.js es una cosa ; Entender
				el porqué ellas necesitan ser escritas en la manera que lo son
				significa entender JavaScript! Y esta vez es en serio.
			</p>
			<p>
				Y aquí esta el problema: Ya que JavaScript realmente vive
				dos, o tal vez tres vidas (El pequeño audante DHTML de 
				mediados de los 90's, las cosas más serias tales como jQuery
				y similares, y ahora, el lado del servidor), no es tan fácil
				encontrar información que te ayude a aprender JavaScript de la
				"manera correcta", de forma de poder escribir aplicaciones de 
				Node.js en una apariencia que te haga sentir que tú no sólo
				estás usando JavaScript, sino que también están desarrollando
				con él.
			</p>
			<p>			
        Porque ahí está el asunto: Tú ya eres un desarrollador
        experimentado, y no quieres aprender una nueva técnica
        simplemente metiendo código aquí y allá mal-aprovechandolo;
        Tú quieres estar seguro que te estás enfocando en un angulo
        correcto.
			</p>
			<p>
        Hay, por supuesto, excelente documentación afuera.
        Pero la documentaión por si sola no es suficiente. Lo que 
        se necesita es una guía.
			</p>
			<p>
        Mi objetivo es proveerte esta guía.
			</p>

			<h3>Una Advertencia</h3>
			<p>
			 Hay algunas personas realmente excelente en JavaScript.
			 No soy una de ellas.
			</p>
			<p>
			 Yo soy realmente el tipo del que te he hablado en los
			 párrafos previos. Sé un par de cosas acerca de desarrollar
			 aplicaciones backend, pero aún soy nuevo al JavaScript "real"
			 y aún más nuevo a Node.js. He aprendido solo recientemente alguno 
			 de los aspectos avanzados de JavaScript. No soy experimentado.
			</p>
			<p>
        Por lo que este no es un libro "desde novicio hasta experto".
        Este es más bien un libro "desde novicio a novicio avanzado".
			</p>
			<p>
				Si no fallo, entonces este será el tipo de documento
				que deseo hubiese tenido cuando empecé con Node.js.
			</p>

			<h3>JavaScript del Lado del Servidor</h3>
			<p>
				Las primeras encarnaciones de JavaScript vivían en los
				browsers. Pero esto es sólo el contexto. Define lo que puedes
				hacer con el lenguaje, pero no dice mucho acerca de lo que el
				lenguaje mismo puede hacer. JavaScript es un lenguaje "completo":
				Lo puedes usar en muchos contextos y alcanzar con éste, todo
				lo que puedes alcanzar con cualquier otro lenguaje "completo".
			</p>
			<p>
				Node.js realmente es sólo otro contexto: te permite correr
				código JavaScript en el backend, fuera del browser.
			</p>
			<p>
				Para ejecutar el código JavaScript que tu pretendes correr en el 
				backend, este necesita ser interpretado y, bueno, ejecutado, Esto
				es lo que Node.js realiza, haciendo uso de la Maquina Virtual V8 de
				Google, el mismo entorno de ejecución para JavaScript que Google
				Chrome utiliza.
			</p>
			<p>
				Además, Node.js viene con muchos módulos utiles, de manera que no
				tienes que escribir todo de cero, como por ejemplo, algo que ponga un
				string a la consola.
			</p>
			<p>
				Entonces, Node.js es en realidad dos cosas: un entorno de ejecución
				y una librería.
			</p>
			<p>
        Para hacer uso de éstas (la librería y el entorno), Tú necesitas
        instalar Node.js. En lugar de repetir el proceso aquí. Te ruego
        visitar <a href="https://github.com/joyent/node/wiki/Installation"
				   title="Building and Installing Node.js">las instrucciones oficiales
				de instalación</a>, Por Favor vuelve una vez que estés arriba y corriendo
				tu versión de Node.js
			</p>

			<h3>"Hola Mundo"</h3>
			<p>
        Ok. Saltemos entonces al agua fría y escribamos nuestra primera
				aplicación Node.js: "Hola Mundo".				
			</p>
			<p>
				Abre tu editor favorito y crea un archivo llamado <em>holamundo.js</em>.
				Nosotors queremos escribir "Hola Mundo" a STDOUT, y aquí esta el código
				necesario para hacer esto:			
			</p>
<pre class="prettyprint lang-js">console.log("Hola Mundo");
</pre>
			<p>
        Graba el archivo, y ejecútalo a través de Node.js:
			</p>
<pre class="prettyprint lang-js">node holamundo.js</pre>
			<p>
				Este debería retornar <em>Hola Mundo</em> en tu monitor.
			</p>
			<p>
				Ok, esto es aburrido, de acuerdo? Así que escribamos alguna cosa real.
			</p>


			<h2>Una Aplicación Web Completa con Node.js</h2>

			<h3>Los casos de Uso</h3>
			<p>
				Mantengámoslo simple, pero realista:
			</p>
			<ul>
				<li>
					El Usuario debería ser capaz de ocupar nuestra aplicación con
					un browser.
				</li>
				<li>
					El Usuario debería ver una página de bienvenida cuando
					solicita http://<em>dominio</em>/inicio.
				</li>
				<li>
					Cuando solicite http://<em>dominio</em>/subir, el 
					Usuario debería ser capaz de subir un archivo de imagen
					desde su computador, el cual es luego desplegado en su
					browser.
				</li>
			</ul>
			<p>
				Muy bien. Ahora, tu puedes ser capaz de alcanzar este objetivo
				googleando y programando <em>lo que sea</em>, pero eso no es lo
				que queremos hacer aquí.
			</p>
			<p>
				Más que eso, no quieremos escribir simplemente el código más
				básico posible para alcanzar este objetivo, no importa lo
				elegante y correcto que pueda ser este código. Nosotros
				agregaremos intencionalmente más abstracción de lo necesaria
				de manera de poder tener una idea de lo que es contruir 
				aplicaciones más complejas de Node.js.
			</p>

			<h3>La Pila de Aplicaciones</h3>
			<p>
				Hagamos un desglose a nuestra aplicación. ¿Qué partes
				necesitan ser implementadas para poder satisfacer
				nuestros casos de uso?
			</p>
			<ul>
				<li>
					Queremos servir páginas web, de manera que necesitamos
					un <strong>Servidor HTTP</strong>.
				</li>
				<li>
					Nuestro servidor necesitará responder directamente
					peticiones (requests), dependiendo de que URL sea pedida en
					este requerimiento, es que necesitaremos algún tipo
					de <strong>enrutador (router)</strong> de manera de
					mapear los peticiones a los handlers (manejadores) de éstos.
				</li>
				<li>
					Para satisfacer a los peticiones que llegaron 
					al servidor y han sido ruteados usando el enrutador,
					necesitaremos de hecho 
					<strong>handlers (manejadores) de peticiones</strong>
				</li>
				<li>
					El Enrutador probablemente debería tratar cualquier
					información POST que llegue y darsela a los handlers de
					peticiones en una forma conveniente, luego 
					necesitaremos <strong>manipulación de data requerida</strong>
				</li>
				<li>
					Nosotros no solo queremos manejar peticiones de URLs,
					sino que también queremos desplegar contenido cuando
					estas URLs sean pedidas, lo que significa que necesitamos
					algún tipo de <strong>lógica en las vistas</strong> a
					ser utilizada por los handlers de peticiones, de manera
					de poder enviar contenido al browser del Usuaio.
				</li>
				<li>
					Por último, pero no menos importante, el Usuario será
					capaz de subir imagenes, así que necesitaremos algún 
					tipo de <strong>manipulación de subidas</strong> quien
					ser hará cargo de los detalles.
				</li>
			</ul>
			<p>
				Pensemos un momento acerca de como construirimas esta pila
				de aplicaciones con PHP. No es exactamente un secreto que
				la configuración típica sería un Apache HTTP server con 
				mod_php5 instalado.
				<br/>
				Lo que, a su vez, significa que el tema "Necesitamos ser capaces
				de servir páginas web y recibir peticiones HTTP" ni siquiera
				sucede dentro de PHP mismo.
			</p>
			<p>
				Bueno, con Node.js, las cosas son un poco distintas. Porque
				con Node.js, no solo implementamos nuestra aplicación, nosotros
				también implementamos todo el servidor HTTP completo.
				De hecho, nuestra aplicación web y su servidor web son
				básicamente lo mismo.
			</p>
			<p>
				Esto puede sonar como mucho trabajo, pero veremos en un momento
				que con Node.js, no lo es.
			</p>
			
			<p>
				
				Empecemos por el principio e implementemos la primera parte
				de nuestra pila, el servidor HTTP..
			</p>

			<h3>Construyendo la Pila de Aplicaciones</h3>
			<h4>Un Servidor HTTP Básico</h4>
			<p>
				Cuando llegué al punto donde quería empezar con mi primera
				aplicación Node.js "real", me pregunté no solo como la iba
				a programar, sino que también, como organizar mi código.
				<br/>
				¿Necesitaré tenerlo todo en un archivo? Muchos tutoriales en
				la Web que te enseñan como escribir un servidor HTTP básico en
				Node.js tienen toda la lógica en un solo lugar. ¿Qué pasa
				si yo quiero asegurarme que mi código se mantenga leíble a 
				medida que le vaya agregando más cosas?
			</p>
			<p>
				Resulta, que es relativamente fácil de mantener los 
				distintos aspectos de tu código separados, poniéndolos en
				módulos.
			</p>
			<p>
				Esto te permite tener un archivo <em>main</em> limpio, en
				el cual Tú ejecutas Node.js, y módulos limpios que pueden ser
				utilizados por el archivo <em>main</em> entre muchos otros.
			</p>
			<p>
				Así que vamos a crear un archivo <em>main</em> el cual usaremos
				para iniciar nuestra aplicación, y un archivo de módulo dónde
				residirá el código de nuestro servidor HTTP.

			</p>
			<p>
				Mi impresión es que es más o menos un estandar nombrar a tu
				archivo <em>main</em> como <em>index.js</em>. Tiene sentido
				también que pongamos nuestro módulo de servidor en un archivo
				llamado <em>server.js</em>.
			</p>
			<p>
				Empecemos con el módulo del servidor. Crea el archivo
				<em>server.js</em> en el directorio raíz de tu proyecto,
				y llenalo con el código siguiente:
			</p>
<pre class="prettyprint lang-js">var http = require("http");

http.createServer(function(request, response) {
  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("Hola Mundo");
  response.end();
}).listen(8888);
</pre>

			<p>
				Eso es! Acabas de escribir un servidor HTTP activo. Probemóslo
				ejecutándolo y testéandolo. Primero ejecuta tu script con Node.js:
			</p>
<pre class="prettyprint lang-js">node server.js</pre>
			<p>
				Ahora, abre tu browser y apúntalo a
				<a href="http://localhost:8888/" rel="nofollow">http://localhost:8888/</a>.
				Esto debería desplegar una página web que diga "Hola Mundo".
			</p>
			<p>
				Interesante, ¿no? ¿Que tal si hablamos de que está pasando aquí y
				dejamos la pregunta de 'cómo organizar nuestro proyecto' para después?
				Prometo que volveremos a esto.
			</p>

			<h4>Analizando nuestro servidor HTTP</h4>
			<p>
				Bueno, entonces, analicemos que está pasando aquí.
			</p>
			<p>
				La primera línea <em>require</em>, requiere al módulo <em>http</em>
				que viene incluído con Node.js y lo hace accesible a través de la
				variable <em>http</em>.
			</p>
			<p>
				Luego llamamos a una de las funciones que el módulo http ofrece:
				<em>createServer</em>. Esta función retorna un objeto, y este objeto
				tiene un método llamado <em>listen</em> (escucha), y toma un
				valor numérico que indica el número de puerto en que nuestro
				servidor HTTP va a escuchar.
			</p>
			<p>
				Por favor ignora por un segundo a la definición de función
				que sigue a la llave de apertura de <em>http.createServer</em>.
			</p>
			<p>
				Nosotros podríamos haber escrito el código que inicia a nuestro
				servidor y lo hace escuchar al puerto 8888 de la siguiente manera:
			</p>
<pre class="prettyprint lang-js">var http = require("http");
var server = http.createServer();
server.listen(8888);</pre>
			<p>
				Esto hubiese iniciado al servidor HTTP en el puerto 8888
				y no hubiese hecho nada más (ni siquiera respondido alguna
				petición entrante).
			</p>
			<p>
				La parte realmente interesante (y rara, si tu trasfondo es 
				en un lenguaje más conservador, como PHP) es que la definición
				de función está ahí mismo donde uno esperaría el primer
				parámetro de la llamada a <em>createServer()</em>.
			</p>
			<p>
				Resulta que, este definición de función ES el primer
				(y único) parametro que le vamos a dar a la llamada a
				<em>createServer()</em>. Ya que en JavaScript, las funciones
				pueden ser pasadas de un lado a otro como cualquier otro valor.
			</p>

			<h4>Pasando Funciones de un Lado a Otro</h4>
			<p>
				Tú puedes, por ejemplo, hacer algo como esto:				
			</p>
<pre class="prettyprint lang-js">function decir(palabra) {
  console.log(palabra);
}

function ejecutar(algunaFuncion, valor) {
  algunaFuncion(valor);
}

ejecutar(decir, "Hola");</pre>
			<p>
				Lee esto cuidadosamente! Lo que estamos haciendo aquí es,
				nosotros pasamos la función <em>decir</em> como el primer
				parámetro de la función <em>ejecutar</em>. No el valor de retorno
				de <em>decir</em>, sino que <em>decir</em> misma!
			</p>
			
			<p>
				Entonces, <em>decir</em> se convierte en la variable local
				<em>algunaFuncion</em> dentro de <em>ejecutar</em>, y ejecutar
				puede llamar a la función en esta variable usando 
				<em>algunaFuncion()</em> (agregando llaves).
			</p>
			<p>
				Por supuesto, dado que <em>decir</em> toma un parámetro,
				<em>ejecutar</em> puede pasar tal parámetro cuando llama a
				<em>algunaFuncion</em>.
			</p>
			
			
			
			<p>
				Nosotros podemos, tal como lo hicimos, pasar una función
				por su nombre como parámetro a otra función. Pero no
				estamos obligados a tener que definir la función primero
				y luego pasarla. Podemos también definir y pasar la función
				como un parametro a otra función todo al mismo tiempo:
			</p>
<pre class="prettyprint lang-js">function ejecutar(algunaFuncion, valor) {
  algunafuncion(valor);
}

ejecutar(function(palabra){ console.log(palabra) }, "Hola");
</pre>
			<p>
				(N.del T.: <em>function</em> es una palabra clave de JavaScript).
			</p>
			<p>
				Nosotros defiunimos la función que queremos pasar a <em>ejecutar</em>
				justo ahí en el lugar donde <em>ejecutar</em> espera su primer
				parámetro.
			</p>
			<p>
				De esta manera, no necesitamos darle a la función un nombre,
				por lo que esta función es llamada <em>función anónima</em>.
			</p>
			<p>
				Esta es una primera ojeada a lo que me gusta llamar JavaScript
				"avanzado". Pero tomémoslo paso a paso. Por ahora, aceptemos que
				en JavaScript, nosotros podemos pasar una función como un parámetro
				cuando llamamos a otra función. Podemos hacer esto asignando
				nuestra función a una variable, la cual luego pasamos, o definiendo
				la función a pasar en el mismo lugar.
			</p>						
			
			<h4>De Qué manera el pasar funciones hace que nuestro servidor HTTP funcione</h4>
			<p>
				Con este conocimiento, Volvamos a nuestro servidor HTTP
				minimalista:
			</p>
<pre class="prettyprint lang-js">var http = require("http");

http.createServer(function(request, response) {
  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("Hola Mundo");
  response.end();
}).listen(8888);
</pre>
			<p>
				Para ahora, debería quedar claro lo que estamos haciendo acá:
				Estamos pasandole a la función <em>createServer</em> una función
				anónima.
			</p>
			<p>
				Podemos llegar a los mismo refactorizando nuestro código 
				así:				
			</p>
<pre class="prettyprint lang-js">var http = require("http");

function onRequest(request, response) {
  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("Hola Mundo");
  response.end();
}

http.createServer(onRequest).listen(8888);
</pre>
			<p>
				Quizás ahora es un buen momento para preguntar:
				¿Por Qué estamos haciendo esto de esta manera?				
			</p>
			
			<h4>Callbacks Manejadas por Eventos</h4>
			
			<p>
				La respuesta a) No es una no muy fácil de dar (al menos para mi),
				y b) Yace en la naturaleza misma de como Node.js trabaja:
				Está orientado al evento, esa es la razón de porqué es tan
				rápido.
			</p>
			<p>
				Podrías tomarte un tiempo para ller este excelente post (en inglés)
				de Felix Geisendördfer: <a href="http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb">Understanding node.js</a> para alguna explicación de trasfondo.
			</p>
			<p>
				Al final todo se reduce al hecho que Node.js trabaja orientado
				al evento. Ah, y sí, Yo tampoco sé exactamente que significa eso.
				Pero voy a hacer un intento de explicar, el porqué esto tiene
				sentido para nosotros, que queremos escribir aplicaciones
				web en Node.js.			
			</p>
			<p>
				Cuando nosotros llamamos al metodo <em>http.createServer</em>,
				por supuesto que no sólo queremos que el servidor se quede escuchando
				en algún puerto, sino que tambien queremos hacer algo cuando hay
				una petición HTTP a este servidor.
			</p>
			<p>
				El problema es, que esto sucede de manera asincrónica: Puede
				suceder en cualquier momento, pero solo tenemos un único proceso
				en el cual nuestro servidor corre.
			</p>
			<p>
				Cuando escribiemos aplicaciones PHP, esto no nos molesta en
				absoluto: cada vez que hay una petición HTTP, el servidor web
				(por lo general Apache) genera un nuevo proceso solo para esta
				petición, y empieza el script PHP indicado desde cero, el cual
				es ejecutado de principio a fin.
			</p>
			<p>
				Así que respecto al control de flujo, estamos en el medio de
				nuestro programa en Node.js, cuando una nueva petición llega al
				puerto 8888: ¿Cómo manipulamos esto sin volvernos locos?
			</p>
			<p>
				Bueno, esta es la parte donde el diseño orientado al evento
				de Node.js / JavaScript de verdad ayuda, aunque tengamos
				que aprender nuevos conceptos para poder dominarlo. Veamos
				como estos conceptos son aplicados en nuestro código de
				sevidor.
			</p>
			<p>
				Nosotros creamos el servidor, y pasamos una función al método
				que lo crea. Cada vez que nuestro servidor recibe una petición,
				la función que le pasamos será llamada.
			<p>
				No sabemos que es lo que va a suceder, pero ahora tenemos un
				lugar donde vamos a poder manipular la petición entrante.
				Es la función que pasamos, sin importar si la definimos o si
				la pasamos de manera anónima.
			</p>
			<p>
				Este concepto es llamado un <em>callback</em> (del inglés: call =
				llamar; y back = de vuelta). Nosotros pasamos una función a algún
				método, y el método ocupa esta función para llamar (call) de vuelta
				(back) si un evento relacionado con este método ocurre.
			</p>
			<p>
				Al menos para mí, esto tomó algún tiempo para ser entendido. Lee
				el articulo del blog de Felix de nuevo si tú todavía no te sientes
				seguro.
			</p>
			<p>
				Juguemos un poco con este nuevo concepto. ¿Podemos probar que nuestro
				código contnúa despues de haber creado el servidor, incluso
				si no ha sucedido ninguna petición HTTP y la función callback que
				pasamos no ha sido llamada? Probemos:
			<p>
<pre class="prettyprint lang-js">var http = require("http");

function onRequest(request, response) {
  console.log("Peticion Recibida.");
  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("Hola Mundo");
  response.end();
}

http.createServer(onRequest).listen(8888);

console.log("Servidor Iniciado.");
</pre>			

		<p>
			Noten que utilizo <em>console.log</em> para entregar un texto
			cada vez que la función <em>onRequest</em> (nuestro callback) es
			gatillada, y otro texto <em>despues</em> de iniciar nuestro servidor
			HTTP.
		</p>
		<p>
			Cuando iniciamos esta aplicación (con <em>node server.js</em>, como siempre).
			Esta inmediatamente escribirá en pantalla "Servidor Iniciado" en la línea de comandos.
			Cada vez que hagamos una petición a nuestro servidor (abriendo
			<a href="http://localhost:8888/" rel="nofollow">http://localhost:8888/</a> en
			nuestro browser), el mensaje "Peticion Recibida." va a ser impreso en la línea
			de comandos.
		</p>
		<p>
			Esto es JavaScript del Lado del Servidor Asincrónico y orientado al
			evento con callbacks en acción :-)
		</p>
		<p>
			(Toma en cuenta que nuestro servidor probablemente escribirá
			"Petición Recibida." a STDOUT dos veces al abrir la página en un
			browser. Esto es porque la mayoría de los browsers van a tratar de
			cargar el favicon mediante la petición http://localhost:8888/favicon.ico
			cada vez que abras http://localhost:8888/).
		</p>
		
		<h4>Como nuestro Servidor manipula las peticiones</h4>
		
		<p>
			OK, Analicemos rápidamente el resto del código de nuestro servidor, 
			esto es, el cuerpo de nuestra función de callback <em>onRequest()</em>.
		</p>
		<p>
			Cuando la Callback es disparada y nuestra función <em>onRequest()</em> es
			gatillada, dos parámetros son pasados a ella: <em>request</em> y <em>response</em>.
		</p>
		<p>
			Estos on objetos, y tú puedes usar sus métodos para manejar los detalles
			de la petición HTTP ocurrida y responder a la petición (en otras palabras
			enviar algo de vuelta al browser que hizo la petición a tu servidor).
		</p>
		<p>
			Y eso es lo que nuestro código hace: Cada vez que una petición
			es recibida, usa la función <em>response.writeHead()</em> para 
			enviar un estatus HTTP 200 y un content-type (paámetro que define
			que tipo de contenido es) en el encabezado de la respuesta HTTP,
			y la función <em>response.write()</em> para enviar el texto
			"Hola Mundo" en el cuerpo de la respuesta,
		</p>
		<p>
			POr último, nosotros llamamos <em>response.end()</em> para finalizar
			nuestra respuesta
		</p>
		<p>
			Hasta el momento, no nos hemos interesado por los detalles de la
			petición, y ese es el porqué no hemos ocupado el objeto <em>request</em>
			completamente.
		</p>
		
		<h4>Encontrando un lugar para nuestro módulo de servidor</h4>
		<p>
			OK, prometí que volveríamos a al Cómo organizar nuestra aplicación.
			Tenemos el código de nuestro servidor HTTP muy básico en el archivo
			<em>server.js</em>, y mencioné que es común tener un archivo principal
			llamado <em>index.js</em>, el cual es usado para arrancar y partir
			nuestra aplicación haciendo uso de los otros módulos de la aplicación
			(como el módulo de servidor HTTP que vive en <em>server.js</em>).
		</p>
		<p>
			Hablemos de como podemos hacer que nuestro server.js sea un verdadero
			módulo Node.js y que pueda ser usado por nuestro pronto-a-ser-escrito
			archivo principal <em>index.js</em>.
		</p>
		<p>
			Como habrán notado, ya hemos usado módulos en nuestro código, como éste:
		</p>
<pre class="prettyprint lang-js">var http = require("http");

...

http.createServer(...);
</pre>
		<p>
			En algún lugar dentro de Node.js vive un módulo llamado "http", y
			podemos hacer uso de éste en nuestro propio código requiriéndolo
			y asignando el resultado del requerimiento a una variable local.
		</p>
		<p>
			Esto transforma a nuestra variable local en un objeto que acarrea
			todos los métodos públicos que el módulo <em>http</em> provee.
		</p>
		<p>
			Es práctica común elegir el nombre del módulo como nombre para nuestra
			variable local, pero somos libres de escoger cualquiera que nos guste:
		</p>
<pre class="prettyprint lang-js">var foo = require("http");

...

foo.createServer(...);
</pre>
		<p>
			Bien. Ya tenemos claro como hacer uso de los módulos internos de Node.js.
			¿Cómo hacemos para crear nuestros propios módulos, y Cómo los utilizamos?
		</p>
		<p>
			Descubrámoslo transformando nuestro script <em>server,js</em> en un módulo
			real.
		</p>
		<p>
			Sucede que, no tenemos que transformarlo tanto. Hacer que algún código sea
			un Módulo, significa que necesitamos <em>exportar</em> las partes de su
			funcionalidad que queremos proveer a otros scripts que requieran nuestro
			módulo.
		</p>
		<p>
			Por ahora, la funcionalidad que nuestro servidor HTTP necesita exportar es
			simple: Permitir a los scripts que utilicen este módulo arrancar el servidor.
		</p>
		<p>
			Para hacer esto posible, Dotaremos al código de nuestro servidor de una
			función llamada <em>inicio</em>, y exportaremos esta función:
		<p>
<pre class="prettyprint lang-js">var http = require("http");

function inicio() {
  function onRequest(request, response) {
    console.log("Petición Recibida.");
    response.writeHead(200, {"Content-Type": "text/html"});
    response.write("Hola Mundo");
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("El Servidor Ha Arrancado.");
}

exports.inicio = inicio;
</pre>			
			
		<p>
			De este modo, Podemos crear nuestro propio archivo principal <em>index.js</em>,
			y arrancar nuestro servidor HTTP allío, aunque el código para el servidor este
			en nuestro archivo <em>server.js</em>.
		</p>
		<p>
			Crea un archivo <em>index.js</em> con el siguiente contenido:
		</p>
<pre class="prettyprint lang-js">var server = require("./server");

server.start();
</pre>

		<p>
			Como puedes ver, nosotros utilizamos nuestro módulo de servidor
			tal como cualquier otro módulo interno: requiriendo el archivo
			donde está contendio y asignándolo a una variable, con las funciones
			que tenga 'exportadas' disponibles para nosotros.
		</p>










<!-- TUTORIAL END -->
		</div>
		<div id="workinprogressnote">
			<p>
				El Libro de Node.js para el Principiante
				<br /> 
				es un "work in progress", es decir, se está
				<br />
				realizando en este mismo minuto
				<br />
				<strong>Está terminado en un 80%.</strong>
				<br />
				Vuelve diariamente para ver la última versión.
			</p>
			<p>
				La versión que estás leyendo actualmente fue actualizada el
				<br />
				<strong>Domingo 24 de Abril a las 06:52 AM EDT</strong>.
			</p>
			<p>
				La mejor manera de mantenerte informado acerca de actualizaciones
				<br />
				es siguiendo a <a href="http://twitter.com/manuelkiessling">@ManuelKiessling en Twitter</a>.
			</p>
		</div>
		<div id="donate">
			<p>
				El Libro de Node.js para el Principiante está y siempre estará disponible gratis.
				<br />
				No se requieren fondos para mantener al proyecto vivo y en marcha.
				<br />
				Pero si quieres apoyar al Autor, puede hacerlo usando Flatter o Paypal:		
			</p>
			<div id="flattr">
				<a class="FlattrButton" style="display:none;" href="http://www.nodebeginner.org"></a>
			</div>
			<div id="paypal">
				<form action="https://www.paypal.com/cgi-bin/webscr" method="post">
					<fieldset>
						<input type="hidden" name="cmd" value="_s-xclick" />
						<input type="hidden" name="hosted_button_id" value="AWJS7PD37SQ5G" />
						<input type="image" src="https://www.paypalobjects.com/WEBSCR-640-20110401-1/en_US/i/btn/btn_donateCC_LG.gif" name="submit" alt="PayPal - The safer, easier way to pay online!" />
						<img alt="" src="https://www.paypalobjects.com/WEBSCR-640-20110401-1/de_DE/i/scr/pixel.gif" width="1" height="1" />
					</fieldset>
				</form>
			</div>
		</div>
			
		<div id="footer">
			<p id="ccimage">
				<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a>
			</p>			
			<p>The Node Beginner Book by <a target="_blank" href="http://manuel.kiessling.net/">Manuel Kiessling</a> is licensed under a <a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>. Permissions beyond the scope of this license may be available at <a target="_blank" href="mailto:manuel@kiessling.net">manuel@kiessling.net</a>.</p> 
<p>“El Libro del Principiante de Node, por Manuel Kiessling está licenciado bajo la Licencia <a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>. Los permisos más allá del alcance de ésta pueden ser conseguidos en <a target="_blank" href="mailto:manuel@kiessling.net">manuel@kiessling.net</a>. </p>
	
		</div>
	</body>
</html>