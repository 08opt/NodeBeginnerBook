<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link href="prettify/prettify.css" type="text/css" rel="stylesheet" />

		<title>El Libro de Node.js para el Principiante» Un tutorial completo de node.js</title>
		<meta name="description" content="Un tutorial completo de Node.js para principiantes: Aprende como construir una aplicación web completa con Javascript del lado del servidor" />

		<style type="text/css">
			body {
				font-family: Georgia, serif;
				background-color: #eee;
				padding-top: 48px;
				-webkit-text-size-adjust: 200%;
			}

			#book, #donate, #disqus_thread, #footer, #workinprogressnote {
				width: 640px;
				margin: 0 auto;
				margin-top: 24px;
				margin-bottom: 100px;
				padding: 64px;
				background-color: white;
				border-top: 1px solid #ddd;
				border-left: 1px solid #ddd;
				border-bottom: 1px solid #ddd;
				border-right: 1px solid #ddd;
				z-index: 100;

				-moz-box-shadow: 14px 11px 27px #888;
				-webkit-box-shadow: 14px 11px 27px #888;
				box-shadow: 14px 11px 27px #888;
			}

			#author {
				margin-top: -20px;
				margin-left: 250px;
				color: #888;
				font-family: "Helvetica Neue", sans-serif;
				font-size: 75%;
			}

			#updateinfo {
				margin-top: 20px;
				margin-left: 250px;
				color: #bbb;
				font-family: "Helvetica Neue", sans-serif;
				font-size: 75%;
			}

			#workinprogressnote p {
				font-family: "Helvetica Neue", sans-serif;
				color: #700;
				text-align: center;
			}

			#donate p {
				font-family: "Helvetica Neue", sans-serif;
				text-align: center;
			}

			#flattr {
				padding-top: 20px;
				margin-left: 183px;
				margin-right: 18px;
				text-align: center;
				align: left;
				display: inline-block;
				width: 100px;
			}

			#paypal {
				display: inline-block;
				margin-top: 24px;
				text-align: center;
				vertical-align: top;
			}

			#paypal fieldset {
				border: 0;
			}

			#disqus_thread {
				font-family: "Helvetica Neue", sans-serif;
			}

			#footer {
				font-family: "Helvetica Neue", sans-serif;
				background-color: #f5f5f5;
				margin-top: 100px;
			}

			#footer p {
				text-align: center;
				font-family: "Helvetica Neue", sans-serif;
				font-size: 11px;
			}

			#ccimage {
				float: left;
				margin-left: 30px;
				margin-right: 0;
				margin-top: 20px;
			}

			#praise {
				position: absolute;
				top: 120px;
				right: 40px;
				width: 204px;
				font-style: italic;
				color: #aaa;
				z-index: -1;
				text-align: right;
			}

			#praise .praise {
				margin-bottom: 25px;
			}

			#praise .author {
				font-style: normal;
				font-size: 75%;
			}

			#table-of-contents-headline {
				margin-top: 48px;
				color: #700;
				font-size: 160%;
				font-weight: bold;
			}

			#book #table-of-contents {
				margin-left: -24px;
			}

			#book #table-of-contents ul li {
				font-size: 100%;
				margin-left: 0;
				list-style-type: none;
			}

			#book #table-of-contents ul {
				padding-left: 24px;
				margin-top: 12px;
				margin-left: 0;
				margin-bottom: 36px;
			}

			h1 {
				margin-left: -50px;
				margin-top: -50px;
				font-size: 300%;
				color: #444;
				font-style: italic;
    			font-weight: bold;
				-webkit-text-size-adjust: 100%;
			}

			h2 {
				margin-top: 64px;
				font-size: 180%;
			}

			h3 {
				font-size: 160%;
			}

			h4 {
				font-size: 140%;
			}

			h5 {
				font-size: 120%;
			}

			h3, h4, h5 {
				margin-top: 36px;
			}

			h2, h3, h4, h5 {
				color: #700;
				font-weight: bold;
				margin-bottom: 36px;
			}

			#book p {
				text-align: justify;
				font-size: 110%;
				line-height: 150%;
				margin-bottom: 48px;
    			margin-top: -22px;
			}

			pre {
				background-color: #f7f7f7;
				border: 1px solid #eee;
				padding: 16px;
				margin-bottom: 64px;
				margin-top: -24px;
				font-size: 14px;
			}

			pre.prettyprint {
				background-color: #f7f7f7;
				border: 1px solid #eee;
				padding: 16px;
				margin-bottom: 64px;
				margin-top: -24px;
				font-size: 14px;
			}

			#book ul {
				margin-top: -24px;
				margin-bottom: 64px;
			}

			ul li {
				margin-bottom: 12px;
				font-size: 110%;
			}

			blockquote {
				font-style: italic;
			}
		</style>
		<style type="text/css" media="print">
			#forkmeongithub {
				display: none;
			}
			#praise {
				display: none;
			}
		</style>

		<script type="text/javascript" src="mootools-core-1.3.1-full-compat-yc.js"></script>
 		<script type="text/javascript" src="TOC.js"></script>
		<script type="text/javascript">
			window.addEvent('domready', function() {
    			var toc = new TOC('table-of-contents');
			});
		</script>
		<script type="text/javascript" src="prettify/prettify.js"></script>
		<script type="text/javascript">
			var _gaq = _gaq || [];
			_gaq.push(['_setAccount', 'UA-2127388-6']);
			_gaq.push(['_trackPageview']);

			(function() {
				var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
				ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
				var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
			})();
		</script>
		<script type="text/javascript">
		/* <![CDATA[ */
			(function() {
				var s = document.createElement('script'), t = document.getElementsByTagName('script')[0];
				s.type = 'text/javascript';
				s.async = true;
				s.src = 'http://api.flattr.com/js/0.6/load.js?mode=auto';
				t.parentNode.insertBefore(s, t);
			})();
		/* ]]> */
		</script>
	</head>
	<body onload="prettyPrint();">
		<div id="forkmeongithub">
			<a href="https://github.com/ManuelKiessling/NodeBeginnerBook"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://d3nwyuy0nl342s.cloudfront.net/img/71eeaab9d563c2b3c590319b398dd35683265e85/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" /></a>
		</div>

		<div id="book">
			<h1>El Libro para Principiantes en Node.js</h1>
			<div id="author">Un tutorial de Node.js por:<a href="http://twitter.com/manuelkiessling">Manuel Kiessling</a></div>
			<div id="updateinfo">&#218;ltima actualizaci&oacute;n el Domingo 24 de Abril, 2011 a las 6:52 AM EDT</div>
                        <div id="updateinfo">&#218;ltima traducci&oacute;n el Martes 03 de Mayo, 2011 a las 01.11 AM EDT</div>

			<h2>Sobre el Tutorial</h2>

			<p>
				
				El objetivo de este documento es ayudarte a empezar con el
				desarrollo de aplicaciones para Node.js, enseñándote todo lo 
				que necesites saber acerca de Javascript "avanzado" sobre
				la marcha. Este tutorial va mucho más allá del típico manual
				"Hola Mundo".

			</p>
			<p>
				Este documento todavía está siendo escrito y va terminado
				en un 80%.
			</p>

			<h3>Audiencia Objetivo</h3>
			<p>
				Este documento probablemente será mejor entendido por los
				lectores que tengan un trasfondo similar al mío: Programadores
				experimientados en al menos un lenguaje orientado al objeto,
				como Ruby, Python, PHP o Java; poca experiencia con JavaScript, y
				ninguna experiencia en Node.js.
			</p>
			<p>
				El que este documento esté orientado a desarrolladores 
				que ya tienen experiencia con otros lenguajes
				de programación significa que no vamos a cubrir temas 
				realmente básicos como tipos de datos, variables, estructuras
				de control y similares. Se debe saber acerca de estos tópicos
				para entender este documento.
				
			</p>
			<p>
				Sin embargo, dado que las funciones y objetos en JavaScript
				son diferentes de sus contrapartes en la mayoria de los lenguajes,
				estos serán explicados con más detalle.
			</p>

			<h3>Estructura de este documento</h3>
			<p>
				Al Término de este documento, Tú habrás creado una aplicación
				Web completa, que permita a los usuarios de ésta el ver
				páginas web y subir archivos.
			</p>
			<p>
				La cual, por supuesto, no va ser nada como la "aplicación que
				va a cambiar el mundo", no obstente eso, nosotros haremos la
				milla extra y no vamos sólo a codificar una aplicación lo
				"suficientemente simple" para hacer estos casos de uso posible,
				sino que crearemos un framewoirk sencillo, pero completo, a fin de 
				poder separar los distintos aspectos de nuestra aplicación.
				Verás lo que esto significa en poco tiempo.
			</p>
			<p>
				Empezaremos por mirar cómo el desarrollo en JavaScript en Node.js
				es diferente del desarrollo en JavaScript en un browser.
			</p>
			<p>
				Luego, nos mantendremos con la vieja tradición de escribir una
				aplicación "Hola Mundo", la cual es la aplicación más básica
				de Node.js que "hace" algo.
			</p>
			<p>
				Enseguida, discutiremos que tipo de "aplicación del mundo real"
				queremos construir, disectaremos las diferentes partes que necesitan
				ser implementadas para ensamblar esta aplicación, y empezaremos
				trabajando en cada una de estas partes paso a paso.
			</p>
			<p>
				Tal y cual lo prometido, aprenderemos sobre la marcha acerca
				de algunos de los muchos conceptos avanzados de JavaScript,
				como hacer uso de ellos, y ver el porqué tiene sentido el hacer
				uso de estos conceptos en vez de los que ya conocemos por
				otros lenguajes de programación.
			</p>

			<div id="table-of-contents-headline">Tabla de Contenidos</div>
			<div id="table-of-contents"></div>

			<h2>JavaScript y Node.js</h2>

			<h3>JavaScript y Tú</h3>
			<p>
				Antes que hablemos de toda la parte técnica, tomémosnos
				un minuto y hablemos acerca de tí y tu relación con 
				JavaScript. Este capitulo está aquí para permitirte estimar
				si tiene sentido el que sigas o no leyendo este documento.
			</p>
			<p>
				Si tú eres como yo, empezaste con el "desarrollo" HTML
				hace bastante tiempo, escribiendo documentos HTML. Te 
				encontraste en el camino con esta cosa divertida llamada
				JavaScript, pero solo la usabas en una forma muy básica,
				agregando interactividad a tus páginas de cuando en cuando.
			</p>
			<p>
				Lo que Tú realmente querías era "la cosa real", Tú querías
				saber como construir sitios web comlejos - Tú aprendiste un
				lenguaje de programación como PHP, Ruby, Java, y empezaste a 
				escribir codigo "backend".
			</p>
			<p>
				No obstantem tú mantuviste un ojo en JavaScript, y te diste
				cuenta que con la introducción de jQuery, Prototype y otros,
				las cosas se fueron poniendo más avanzadas en las Tierras
				de JavaScript, y que este lenguaje era realmente más que
				<em>window.open()</em>.							
			</p>
			<p>
				Sin embargo, esto era todo cosa del 
				<span style="font-style: italic;">frontend</span> ,y aunque era
				agradable contar con jQuery a tu disposición en cualquier
				momento que te sintieras con animo de sazonar una página web,
				al final del día, tu eras a lo más, un usuario de JavaScript,
				pero no, un desarrollador de JavaScript.
			</p>
			<p>
				Y entonces llegó Node.js. JavaScript en el servidor, ¿Qué
				hay con eso?				
			</p>
			<p>
				Decidiste que era ya tiempo de revisar el nuevo JavaScript.
				Pero espera: Escribir aplicaciones Node.js es una cosa ; Entender
				el porqué ellas necesitan ser escritas en la manera que lo son
				significa entender JavaScript! Y esta vez es en serio.
			</p>
			<p>
				Y aquí esta el problema: Ya que JavaScript realmente vive
				dos, o tal vez tres vidas (El pequeño audante DHTML de 
				mediados de los 90's, las cosas más serias tales como jQuery
				y similares, y ahora, el lado del servidor), no es tan fácil
				encontrar información que te ayude a aprender JavaScript de la
				"manera correcta", de forma de poder escribir aplicaciones de 
				Node.js en una apariencia que te haga sentir que tú no sólo
				estás usando JavaScript, sino que también están desarrollando
				con él.
			</p>
			<p>			
        Porque ahí está el asunto: Tú ya eres un desarrollador
        experimentado, y no quieres aprender una nueva técnica
        simplemente metiendo código aquí y allá mal-aprovechandolo;
        Tú quieres estar seguro que te estás enfocando en un angulo
        correcto.
			</p>
			<p>
        Hay, por supuesto, excelente documentación afuera.
        Pero la documentaión por si sola no es suficiente. Lo que 
        se necesita es una guía.
			</p>
			<p>
        Mi objetivo es proveerte esta guía.
			</p>

			<h3>Una Advertencia</h3>
			<p>
			 Hay algunas personas realmente excelente en JavaScript.
			 No soy una de ellas.
			</p>
			<p>
			 Yo soy realmente el tipo del que te he hablado en los
			 párrafos previos. Sé un par de cosas acerca de desarrollar
			 aplicaciones backend, pero aún soy nuevo al JavaScript "real"
			 y aún más nuevo a Node.js. He aprendido solo recientemente alguno 
			 de los aspectos avanzados de JavaScript. No soy experimentado.
			</p>
			<p>
        Por lo que este no es un libro "desde novicio hasta experto".
        Este es más bien un libro "desde novicio a novicio avanzado".
			</p>
			<p>
				Si no fallo, entonces este será el tipo de documento
				que deseo hubiese tenido cuando empecé con Node.js.
			</p>

			<h3>JavaScript del Lado del Servidor</h3>
			<p>
				Las primeras encarnaciones de JavaScript vivían en los
				browsers. Pero esto es sólo el contexto. Define lo que puedes
				hacer con el lenguaje, pero no dice mucho acerca de lo que el
				lenguaje mismo puede hacer. JavaScript es un lenguaje "completo":
				Lo puedes usar en muchos contextos y alcanzar con éste, todo
				lo que puedes alcanzar con cualquier otro lenguaje "completo".
			</p>
			<p>
				Node.js realmente es sólo otro contexto: te permite correr
				código JavaScript en el backend, fuera del browser.
			</p>
			<p>
				Para ejecutar el código JavaScript que tu pretendes correr en el 
				backend, este necesita ser interpretado y, bueno, ejecutado, Esto
				es lo que Node.js realiza, haciendo uso de la Maquina Virtual V8 de
				Google, el mismo entorno de ejecución para JavaScript que Google
				Chrome utiliza.
			</p>
			<p>
				Además, Node.js viene con muchos módulos utiles, de manera que no
				tienes que escribir todo de cero, como por ejemplo, algo que ponga un
				string a la consola.
			</p>
			<p>
				Entonces, Node.js es en realidad dos cosas: un entorno de ejecución
				y una librería.
			</p>
			<p>
        Para hacer uso de éstas (la librería y el entorno), Tú necesitas
        instalar Node.js. En lugar de repetir el proceso aquí. Te ruego
        visitar <a href="https://github.com/joyent/node/wiki/Installation"
				   title="Building and Installing Node.js">las instrucciones oficiales
				de instalación</a>, Por Favor vuelve una vez que estés arriba y corriendo
				tu versión de Node.js
			</p>

			<h3>"Hola Mundo"</h3>
			<p>
        Ok. Saltemos entonces al agua fría y escribamos nuestra primera
				aplicación Node.js: "Hola Mundo".				
			</p>
			<p>
				Abre tu editor favorito y crea un archivo llamado <em>holamundo.js</em>.
				Nosotors queremos escribir "Hola Mundo" a STDOUT, y aquí esta el código
				necesario para hacer esto:			
			</p>
<pre class="prettyprint lang-js">console.log("Hola Mundo");
</pre>
			<p>
        Graba el archivo, y ejecútalo a través de Node.js:
			</p>
<pre>node holamundo.js</pre>
			<p>
				Este debería retornar <em>Hola Mundo</em> en tu monitor.
			</p>
			<p>
				Ok, esto es aburrido, de acuerdo? Así que escribamos alguna cosa real.
			</p>


			<h2>Una Aplicación Web Completa con Node.js</h2>

      <!-- LANDMARK LAST -->

			<h3>Los casos de Uso</h3>
			<p>
				Mantengámoslo simple, pero realista:
			</p>
			<ul>
				<li>
					El Usuario debería ser capaz de ocupar nuestra aplicación con
					un browser.
				</li>
				<li>
					El Usuario debería ver una página de bienvenida cuando
					solicita http://<em>dominio</em>/inicio.
				</li>
				<li>
					Cuando solicite http://<em>dominio</em>/subir, el 
					Usuario debería ser capaz de subir un archivo de imagen
					desde su computador, el cual es luego desplegado en su
					browser.
				</li>
			</ul>
			<p>
				Muy bien. Ahora, tu puedes ser capaz de alcanzar este objetivo
				googleando y programando <em>lo que sea</em>, pero eso no es lo
				que queremos hacer aquí.
			</p>
			<p>
				Más que eso, no quieremos escribir simplemente el código más
				básico posible para alcanzar este objetivo, no importa lo
				elegante y correcto que pueda ser este código. Nosotros
				agregaremos intencionalmente más abstracción de lo necesaria
				de manera de poder tener una idea de lo que es contruir 
				aplicaciones más complejas de Node.js.
			</p>

			<h3>La Pila de Aplicaciones</h3>
			<p>
				Hagamos un desglose a nuestra aplicación. ¿Qué partes
				necesitan ser implementadas para poder satisfacer
				nuestros casos de uso?
			</p>
			<ul>
				<li>
					Queremos servir páginas web, de manera que necesitamos
					un <strong>Servidor HTTP</strong>.
				</li>
				<li>
					Nuestro servidor necesitará responder directamente
					peticiones (requests), dependiendo de que URL sea pedida en
					este requerimiento, es que necesitaremos algún tipo
					de <strong>enrutador (router)</strong> de manera de
					mapear los peticiones a los handlers (manejadores) de éstos.
				</li>
				<li>
					Para satisfacer a los peticiones que llegaron 
					al servidor y han sido ruteados usando el enrutador,
					necesitaremos de hecho 
					<strong>handlers (manejadores) de peticiones</strong>
				</li>
				<li>
					El Enrutador probablemente debería tratar cualquier
					información POST que llegue y darsela a los handlers de
					peticiones en una forma conveniente, luego 
					necesitaremos <strong>manipulación de data requerida</strong>
				</li>
				<li>
					Nosotros no solo queremos manejar peticiones de URLs,
					sino que también queremos desplegar contenido cuando
					estas URLs sean pedidas, lo que significa que necesitamos
					algún tipo de <strong>lógica en las vistas</strong> a
					ser utilizada por los handlers de peticiones, de manera
					de poder enviar contenido al browser del Usuaio.
				</li>
				<li>
					Por último, pero no menos importante, el Usuario será
					capaz de subir imagenes, así que necesitaremos algún 
					tipo de <strong>manipulación de subidas</strong> quien
					ser hará cargo de los detalles.
				</li>
			</ul>
			<p>
				Pensemos un momento acerca de como construirimas esta pila
				de aplicaciones con PHP. No es exactamente un secreto que
				la configuración típica sería un Apache HTTP server con 
				mod_php5 instalado.
				<br/>
				Lo que, a su vez, significa que el tema "Necesitamos ser capaces
				de servir páginas web y recibir peticiones HTTP" ni siquiera
				sucede dentro de PHP mismo.
			</p>
			<p>
				Bueno, con Node.js, las cosas son un poco distintas. Porque
				con Node.js, no solo implementamos nuestra aplicación, nosotros
				también implementamos todo el servidor HTTP completo.
				De hecho, nuestra aplicación web y su servidor web son
				básicamente lo mismo.
			</p>
			<p>
				Esto puede sonar como mucho trabajo, pero veremos en un momento
				que con Node.js, no lo es.
			</p>
			
			<p>
				
				Empecemos por el principio e implementemos la primera parte
				de nuestra pila, el servidor HTTP..
			</p>

			<h3>Construyendo la Pila de Aplicaciones</h3>
			<h4>Un Servidor HTTP Básico</h4>
			<p>
				Cuando llegué al punto donde quería empezar con mi primera
				aplicación Node.js "real", me pregunté no solo como la iba
				a programar, sino que también, como organizar mi código.
				<br/>
				¿Necesitaré tenerlo todo en un archivo? Muchos tutoriales en
				la Web que te enseñan como escribir un servidor HTTP básico en
				Node.js tienen toda la lógica en un solo lugar. ¿Qué pasa
				si yo quiero asegurarme que mi código se mantenga leíble a 
				medida que le vaya agregando más cosas?
			</p>
			<p>
				Resulta, que es relativamente fácil de mantener los 
				distintos aspectos de tu código separados, poniéndolos en
				módulos.
			</p>
			<p>
				Esto te permite tener un archivo <em>main</em> limpio, en
				el cual Tú ejecutas Node.js, y módulos limpios que pueden ser
				utilizados por el archivo <em>main</em> entre muchos otros.
			</p>
			<p>
				Así que vamos a crear un archivo <em>main</em> el cual usaremos
				para iniciar nuestra aplicación, y un archivo de módulo dónde
				residirá el código de nuestro servidor HTTP.

			</p>
			<p>
				Mi impresión es que es más o menos un estandar nombrar a tu
				archivo <em>main</em> como <em>index.js</em>. Tiene sentido
				también que pongamos nuestro módulo de servidor en un archivo
				llamado <em>server.js</em>.
			</p>
			<p>
				Empecemos con el módulo del servidor. Crea el archivo
				<em>server.js</em> en el directorio raíz de tu proyecto,
				y llenalo con el código siguiente:
			</p>
<pre><code>var http = require("http");

http.createServer(function(request, response) {
  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("Hola Mundo");
  response.end();
}).listen(8888);
</code></pre>

			<p>
				Eso es! Acabas de escribir un servidor HTTP activo. Probemóslo
				ejecutándolo y testéandolo. Primero ejecuta tu script con Node.js:
			</p>
<pre>node server.js</pre>
			<p>
				Ahora, abre tu browser y apúntalo a
				<a href="http://localhost:8888/" rel="nofollow">http://localhost:8888/</a>.
				Esto debería desplegar una página web que diga "Hola Mundo".
			</p>
			<p>
				Interesante, ¿no? ¿Que tal si hablamos de que está pasando aquí y
				dejamos la pregunta de 'cómo organizar nuestro proyecto' para después?
				Prometo que volveremos a esto.
			</p>

			<h4>Analizando nuestro servidor HTTP</h4>
			<p>
				Bueno, entonces, analicemos que está pasando aquí.
			</p>
			<p>
				La primera línea <em>require</em>, requiere al módulo <em>http</em>
				que viene incluído con Node.js y lo hace accesible a través de la
				variable <em>http</em>.
			</p>
			<p>
				Luego llamamos a una de las funciones que el módulo http ofrece:
				<em>createServer</em>. Esta función retorna un objeto, y este objeto
				tiene un método llamado <em>listen</em> (escucha), y toma un
				valor numérico que indica el número de puerto en que nuestro
				servidor HTTP va a escuchar.
			</p>
			<p>
				Por favor ignora por un segundo a la definición de función
				que sigue a la llave de apertura de <em>http.createServer</em>.
			</p>
			<p>
				Nosotros podríamos haber escrito el código que inicia a nuestro
				servidor y lo hace escuchar al puerto 8888 de la siguiente manera:
			</p>
<pre><code>var http = require("http");
var server = http.createServer();
server.listen(8888);</code></pre>
			<p>
				Esto hubiese iniciado al servidor HTTP en el puerto 8888
				y no hubiese hecho nada más (ni siquiera respondido alguna
				petición entrante).
			</p>
			<p>
				La parte realmente interesante (y rara, si tu trasfondo es 
				en un lenguaje más conservador, como PHP) es que la definición
				de función está ahí mismo donde uno esperaría el primer
				parámetro de la llamada a <em>createServer()</em>.
			</p>
			<p>
				Resulta que, este definición de función ES el primer
				(y único) parametro que le vamos a dar a la llamada a
				<em>createServer()</em>. Ya que en JavaScript, las funciones
				pueden ser pasadas de un lado a otro como cualquier otro valor.
			</p>

			<h4>Pasando Funciones de un Lado a Otro</h4>
			<p>
				Tú puedes, por ejemplo, hacer algo como esto:				
			</p>
<pre><code>function decir(palabra) {
  console.log(palabra);
}

function ejecutar(algunaFuncion, valor) {
  algunaFuncion(valor);
}

ejecutar(decir, "Hola");</code></pre>
			<p>
				Lee esto cuidadosamente! Lo que estamos haciendo aquí es,
				nosotros pasamos la función <em>decir</em> como el primer
				parámetro de la función <em>ejecutar</em>. No el valor de retorno
				de <em>decir</em>, sino que <em>decir</em> misma!
			</p>
			
			<p>
				Entonces, <em>decir</em> se convierte en la variable local
				<em>algunaFuncion</em> dentro de <em>ejecutar</em>, y ejecutar
				puede llamar a la función en esta variable usando 
				<em>algunaFuncion()</em> (agregando llaves).
			</p>
			<p>
				Por supuesto, dado que <em>decir</em> toma un parámetro,
				<em>ejecutar</em> puede pasar tal parámetro cuando llama a
				<em>algunaFuncion</em>.
			</p>
			
			<!-- LANDMARK START-->
			
			<p>
				We can, as we just did, pass a function as a parameter to
				another function by its name. But we don't have to take this
				indirection of first defining, then passing it - we can
				define and pass a function as a parameter to another
				function in-place:
			</p>
<pre class="prettyprint lang-js">function execute(someFunction, value) {
  someFunction(value);
}

execute(function(word){ console.log(word) }, "Hello");
</pre>
			<p>
				We define the function we want to pass to <em>execute</em>
				right there at the place where <em>execute</em> expects its
				first parameter.
			</p>
			<p>
				This way, we don't even need to give the function a name,
				which is why this is called an <em>anonymous function</em>.
			</p>
			<p>
				This is a first glimpse at what I like to call "advanced"
				JavaScript, but let's take it step by step. For now, let's
				just accept that in JavaScript, we can pass a function as
				a parameter when calling another function. We can do this
				by assigning our function to a variable, which we then
				pass, or by defining the function to pass in-place.
			</p>

			<h4>How function passing makes our HTTP server work</h4>
			<p>
				With this knowledge, let's get back to our minimalistic
				HTTP server:
			</p>
<pre class="prettyprint lang-js">var http = require("http");

http.createServer(function(request, response) {
  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("Hello World");
  response.end();
}).listen(8888);
</pre>
			<p>
				By now it should be clear what we are actually doing here:
				we pass the <em>createServer</em> function an anonymous
				function.
			</p>
			<p>
				We could achieve the same by refactoring our code to:
			</p>
<pre class="prettyprint lang-js">var http = require("http");

function onRequest(request, response) {
  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("Hello World");
  response.end();
}

http.createServer(onRequest).listen(8888);
</pre>
			<p>
				Maybe now is a good moment to ask: Why are we doing it
				that way?
			</p>
			
			<!-- LANDMARK END-->	
			

			<h4>Callbacks Manejadas por Eventos</h4>
			<p>
				The answer is a) not that easy to give (at least for me), and
				b) lies in the very nature of how Node.js works. It's
				event-driven, which is the reason why it's so fast.
			</p>
			<p>
				You might want to take the time to read Felix
				Geisendörfer's excellent post
				<a href="http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb">Understanding node.js</a>
				for some background explanation.
			</p>
			<p>
				It all boils down to the fact that Node.js works event-driven.
				Oh and yes, I, too, don't know exactly what that means.
				But I will try and explain, why this makes sense for us
				who want to write web based applications in Node.js.
			</p>
			<p>
				When we call the <em>http.createServer</em> method, we
				of course not only want to have a server listening at
				some port, we also want to do something when there is an
				HTTP request to this server.
			</p>
			<p>
				The problem is, this happens asynchronously: it happens
				at any given time, but we only have a single process in
				which our server runs.
			</p>
			<p>
				When writing PHP applications, we aren't bothered by this
				at all: whenever there is an incoming HTTP request, the
				webserver (usually Apache) forks a new process for just
				this request, and starts the according PHP script from
				scratch, which is then executed from top to bottom.
			</p>
			<p>
				So in regards of control flow, we are in the midst of our
				Node.js program when a new request arrives at port 8888 - how
				to handle this without going insane?
			</p>
			<p>
				Well, this is where the event-driven design of
				Node.js/JavaScript actually helps, although we need to learn
				some new concepts in order to master it. Let's see how
				these concepts are applied in our server code.
			</p>
			<p>
				We create the server, and pass a function to the method
				creating it. Whenever our server receives a request, the
				function we passed will be called.
			</p>
			<p>
				We don't know when this is going to happen, but we now have
				a place where we can handle an incoming request. It's our
				passed function, no matter if we first defined it or passed
				it anonymously.
			</p>
			<p>
				This concept is called a <em>callback</em>. We pass into
				some method a function, and the method uses this function
				to <em>call back</em> if an event related to the method
				occurs.
			</p>
			<p>
				At least for me, this took some time to understand. Just
				read Felix' blog post again if you are still unsure.
			</p>
			<p>
				Let's play around a bit with this new concept. Can we prove
				that our code continues after creating the server, even if
				no HTTP request happened and the callback function we
				passed isn't called? Let's try it:
			</p>
<pre class="prettyprint lang-js">var http = require("http");

function onRequest(request, response) {
  console.log("Request received.");
  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("Hello World");
  response.end();
}

http.createServer(onRequest).listen(8888);

console.log("Server has started.");
</pre>
			<p>
				Note that I use <em>console.log</em> to	output a text whenever
				the <em>onRequest</em> function (our callback) is triggered,
				and	another text right <em>after</em> starting the HTTP server.
			</p>
			<p>
				When we start this (<em>node server.js</em>, as always), it
				will immediately output "Server has started." on the
				command line. Whenever we request our server (by opening
				<a href="http://localhost:8888/" rel="nofollow">http://localhost:8888/</a>
				in our browser), the message "Request received." is printed
				on the command line.
			</p>
			<p>
				Event-driven asynchronous server-side JavaScript with
				callbacks in action :-)
			</p>
			<p>
				(Note that our server will probably write "Request received."
				to STDOUT two times upon opening the page in a browser. That's
				because most browser will try to load the favicon by requesting
				http://localhost:8888/favicon.ico whenever you open
				http://localhost:8888/).
			</p>

			<h4>How our server handles requests</h4>
			<p>
				Ok, let's quickly analyze the rest of our server code, that
				is, the body of our callback function <em>onRequest()</em>.
			</p>
			<p>
				When the callback fires and our <em>onRequest()</em> function
				gets triggered, two parameters are passed into it:
				<em>request</em> and <em>response</em>.
			</p>
			<p>
				Those are objects, and you can use their methods to handle
				the	details of the HTTP request that occured and to respond
				to the request (i.e., to actually send something over
				the wire back to the browser that requested your server).
			</p>
			<p>
				And our code does just that: Whenever a request is
				received, it uses the <em>response.writeHead()</em>
				function to send an HTTP status 200 and content-type in the
				HTTP response header, and the <em>response.write()</em>
				function to send the text "Hello World" in the HTTP
				response body.
			</p>
			<p>
				At last, we call <em>response.end()</em> to actually finish
				our response.
			</p>
			<p>
				At this point, we don't care for the details of the
				request, which is why we don't use the <em>request</em>
				object at all.
			</p>

		
			
			
			
			<h4>Finding a place for our server module</h4>
			<p>
				Ok, I promised we will get back to how to organize our
				application. We have the code for a very basic HTTP server in
				the file <em>server.js</em>, and I mentioned that it's common
				to have a main file called <em>index.js</em> which is used
				to bootstrap and start our application by making use of the
				other modules of the application (like the HTTP server module
				that lives in <em>server.js</em>).
			</p>
			<p>
				Let's talk about how to make server.js a real Node.js module
				that can be used by our yet-to-be-written <em>index.js</em>
				main file.
			</p>
			<p>
				As you may have noticed, we already used modules in our code,
				like this:
			</p>
<pre class="prettyprint lang-js">var http = require("http");

...

http.createServer(...);
</pre>
			<p>
				Somewhere within Node.js lives a module called "http", and we can
				make use of it in our own code by requiring it and assigning
				the result of the require to a local variable.
			</p>
			<p>
				This makes our local variable an object that carries all the
				public methods the <em>http</em> module provides.
			</p>
			<p>
				It's common practice to choose the name of the module for the
				name of the local variable, but we are free to choose whatever
				we like:
			</p>
<pre class="prettyprint lang-js">var foo = require("http");

...

foo.createServer(...);
</pre>
			<p>
				Fine, it's clear how to make use of internal Node.js modules. How
				do we create our own modules, and how do we use them?
			</p>
			<p>
				Let's find out by turning our <em>server.js</em> script into a
				real module.
			</p>
			<p>
				Turns out, we don't have to change that much. Making some code
				a module means we need to <em>export</em> those parts of its
				functionality that we want to provide to scripts that require
				our module.
			</p>
			<p>
				For now, the functionality our HTTP server needs to export is
				simple: scripts requiring our server module simply need to
				start the server.
			</p>
			<p>
				To make this possible, we will put our server code into a
				function named <em>start</em>, and we will export this
				function:
			</p>
<pre class="prettyprint lang-js">var http = require("http");

function start() {
  function onRequest(request, response) {
    console.log("Request received.");
    response.writeHead(200, {"Content-Type": "text/html"});
    response.write("Hello World");
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("Server has started.");
}

exports.start = start;
</pre>
			<p>
				This way, we can now create our main file <em>index.js</em>,
				and start our HTTP there, although the code for the server is
				still in our <em>server.js</em> file.
			</p>
			<p>
				Create a file <em>index.js</em> with the following content:
			</p>
<pre class="prettyprint lang-js">var server = require("./server");

server.start();
</pre>
			<p>
				As you can see, we can use our server module just like any
				internal module: by requiring its file and assigning it to
				a variable, its exported functions become available to us.
			</p>
			<p>
				That's it. We can now start our app via our main script, and it
				still does exactly the same:
			</p>
<pre>node index.js</pre>
			<p>
				Great, we now can put the different parts of our application
				into different files and wire them together by making them
				modules.
			</p>
			<p>
				We still have only the very first part of our application in
				place: we can receive HTTP requests. But we need to do
				something with them - depending on which URL the browser
				requested from our server, we need to react differently.
			</p>
			<p>
				For a very simple application, you could do this directly
				within the callback function <em>onRequest()</em>. But as I said,
				let's add a bit more abstraction in order to make our example
				application a bit more interesting.
			</p>
			<p>
				Making different HTTP requests point at different parts of our
				code is called "routing" - well, then, let's create a module
				called <em>router</em>.
			</p>

			<h4>What's needed to "route" requests?</h4>
			<p>
				We need to be able to feed the requested URL and possible
				additional GET and POST parameters into our router, and based
				on these the router then needs to be able to decide which code
				to execute (this "code to execute" is the third part of our
				application: a collection of request handlers that do the
				actual work when a request is received).
			</p>
			<p>
				So, we need to look into the HTTP requests and extract the
				requested URL as well as the GET/POST parameters from them.
				It could be argued if that should be part of the router or
				part of the server (or even a module of its own), but let's
				just agree on making it part of our HTTP server for now.
			</p>
			<p>
				All the information we need is available through the
				<em>request</em> object which is passed as the first parameter
				to our callback function <em>onRequest()</em>. But to interpret
				this information, we need some additional Node.js modules, namely
				<em>url</em> and <em>querystring</em>.
			</p>
			<p>
				The <em>url</em> module provides methods which allow us to
				extract the different parts of a URL (like e.g. the requested
				path and query string), and <em>querystring</em> can in turn be
				used to parse the query string for request parameters:
			</p>
<pre>                               url.parse(string).query
                                           |
           url.parse(string).pathname      |
                       |                   |
                       |                   |
                     ------ -------------------
http://localhost:8888/start?foo=bar&amp;hello=world
                                ---       -----
                                 |          |
                                 |          |
              querystring(string)["foo"]    |
                                            |
                         querystring(string)["hello"]
</pre>
			<p>
				We can, of course, also use <em>querystring</em> to parse the
				body of a POST request body for parameters, as we will see
				later.
			</p>
			<p>
				Let's now add to our <em>onRequest()</em> function the logic
				needed to find out which URL path the browser requested:
			</p>
<pre class="prettyprint lang-js">var http = require("http");
var url = require("url");

function start() {
  function onRequest(request, response) {
	var pathname = url.parse(request.url).pathname;
	console.log("Request for " + pathname + " received.");
	response.writeHead(200, {"Content-Type": "text/html"});
	response.write("Hello World");
	response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("Server has started.");
}

exports.start = start;
</pre>
			<p>
				Fine. Our application can now distinguish requests based on the
				URL path requested - this allows us to map requests to our
				request handlers based on the URL path using our (yet to be
				written) router. Thus, we can build our application in a
				RESTful way, because we can now implement an interface that
				follows the guiding principle of <em>Identification of
				resources</em> (see
				<a href="http://en.wikipedia.org/wiki/Representational_State_Transfer#Guiding_principles_of_the_interface">the Representational State Transfer article on Wikipedia</a>
				for background information).
			</p>
			<p>
				In the context of our application, it simply means that we will
				be able to have requests for the <em>/start</em> and
				<em>/upload</em> URLs handled by different parts of our
				code. We will see how everything fits together soon.
			</p>
			<p>
				Ok, it's time to actually write our router. Create a new file
				called <em>router.js</em>, with the following content:
			</p>
<pre class="prettyprint lang-js">function route(pathname) {
  console.log("About to route a request for " + pathname);
}

exports.route = route;
</pre>
			<p>
				Of course, this code basically does nothing, but that's ok for
				now. Let's first see how to wire together this router with our
				server before putting more logic into the router.
			</p>
			<p>
				Our HTTP server needs to know about and make use of our router.
				We could hard-wire this dependency into the server, but because
				we learned the hard way from our experience with other
				programming languages, we are going to loosely couple server
				and router by injection this dependency (you may want to read
				<a href="http://martinfowler.com/articles/injection.html">Martin Fowlers excellent post on Dependency Injection</a>
				for	background information).
			</p>
			<p>
				Let's first extend our server's <em>start()</em> function in
				order to enable us to pass the route function to be used by
				parameter:
			</p>
<pre class="prettyprint lang-js">var http = require("http");
var url = require("url");

function start(route) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log("Request for " + pathname + " received.");

    route(pathname);

    response.writeHead(200, {"Content-Type": "text/html"});
    response.write("Hello World");
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("Server has started.");
}

exports.start = start;
</pre>
			<p>
				And let's extend our <em>index.js</em> accordingly, that is,
				injecting the route function of our router into the server:
			</p>
<pre class="prettyprint lang-js">var server = require("./server");
var router = require("./router");

server.start(router.route);

</pre>
			<p>
				Again, we are passing a function, which by now isn't any news
				for us.
			</p>
			<p>
				If we start our application now (<em>node index.js,
				as always</em>), and request an URL, you can now see from the
				application's output that our HTTP server makes use of our
				router and passes it the requested pathname:
			</p>
<pre>bash$ node index.js
Request for /foo received.
About to route a request for /foo
</pre>
			<p>
				(I omitted the rather annoying output for the /favicon.ico
				request).
			</p>

			<h4>Execution in the kingdom of verbs</h4>
			<p>
				May I once again stray away for a while and talk about
				functional programming again?
			</p>
			<p>
				Passing functions is not only a technical consideration.
				With regard to software design, it's almost philosophical.
				Just think about it: in our index file, we could have passed
				the	<em>router</em> object into the server, and the server
				could have called this object's <em>route</em> function.
			</p>
			<p>
				This way, we would have passed a <em>thing</em>, and the server
				would have used this thing to <em>do</em> something. Hey,
				router thing, could you please route this for me?
			</p>
			<p>
				But the server doesn't need the thing. It only needs to get
				something <em>done</em>, and to get something done, you don't
				need things at all, you need <em>actions</em>. You don't need
				<em>nouns</em>, you need <em>verbs</em>.
			</p>
			<p>
				Understanding the fundamental mind-shift that's at the core of
				this idea is what made me really understand functional
				programming.
			</p>
			<p>
				And I did understand it when reading Steve Yegge's masterpiece
				<a href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html">Execution in the Kingdom of Nouns</a>.
				Go read it now, really. It's one of the best writings related
				to software I ever had the pleasure to encounter.
			</p>

			<h4>Routing to real request handlers</h4>
			<p>
				Back to business. Our HTTP server and our request router are
				now best friends and talk to each other as we intended.
			</p>
			<p>
				Of course, that's not enough. "Routing" means, we want to
				handle requests to different URLs differently. We would like to
				have the "business logic" for requests to <em>/start</em>
				handled in another function than requests to <em>/upload</em>.
			</p>
			<p>
				Right now, the routing "ends" in the router, and the router is
				not the place to actually "do" something with the requests,
				because that wouldn't scale well once our application becomes
				more complex.
			</p>
			<p>
				Let's call these functions, where requests are routed to,
				<em>request handlers</em>. And let's tackle those next, because
				unless we have these in place there isn't much sense in doing
				anything with the router for now.
			</p>
			<p>
				New application part, new module - no surprise here. Let's
				create a module called requestHandlers, add a placeholder
				function for every request handler, and export these as
				methods of the module:
			</p>
<pre class="prettyprint lang-js">function start() {
  console.log("Request handler 'start' was called.");
}

function upload() {
  console.log("Request handler 'upload' was called.");
}

exports.start = start;
exports.upload = upload;
</pre>
			<p>
				This allows us to wire the request handlers into the router,
				giving our router something to route to.
			</p>
			<p>
				At this point we need to make a decision: do we hard-code usage
				of the requestHandlers module into the router, or do we want a
				bit more dependency injection? Although dependency injection,
				like every other pattern, shouldn't be used only for the sake
				of using it, in this case it makes sense to loosely couple the
				router and its request handlers, and thus making the router
				really reusable.
			</p>
			<p>
				This means we need to pass the request handlers from our server
				into our router, but this feels even more wrong, which is why
				we should go the whole way and pass them to the server from	our
				main file, and passing it on to the router from there.
			</p>
			<p>
				How are we going to pass them? Right now we have two handlers,
				but in a real application, this number is going to increase and
				vary, and we sure don't want to fiddle around mapping requests
				to handlers in the router anytime a new URL / request handler
				is added. And having some
				<em>if request == x then call handler y</em> in the router
				would be more than ugly.
			</p>
			<p>
				A varying number of items, each mapped to a string (the
				requested URL)? Well, sounds like an associative array would be
				a perfect fit.
			</p>
			<p>
				Well, this finding is slightly disappointed by the fact that
				JavaScript doesn't provide associative array - or does it?
				Turns out, it's actually objects that we want to use if we need
				an associative array!
			</p>
			<p>
				There's a nice introduction to this at
				<a href="http://msdn.microsoft.com/en-us/magazine/cc163419.aspx">http://msdn.microsoft.com/en-us/magazine/cc163419.aspx</a>,
				let me quote the relevant part:
			</p>
			<blockquote>
				<p>
					In C++ or C#, when we’re talking about objects, we're
					referring to instances of classes or structs. Objects have
					different properties and methods, depending on which
					templates (that is, classes) they are instantiated from.
					That's not the case with JavaScript objects. In JavaScript,
					objects are just collections of name/value pairs - think of a
					JavaScript object as a dictionary with string keys.
				</p>
			</blockquote>
			<p>
				If JavaScript objects are just collections of name/value pairs,
				how can they have methods? Well, the values can be strings,
				numbers etc. - or functions!
			</p>
			<p>
				Ok, now finally back to the code. We decided we want to pass
				the list of requestHandlers as an object, and in order to
				achieve loose coupling we want to inject this object into the
				<em>route()</em>.
			</p>
			<p>
				Let's start with putting the object together in our main file
				<em>index.js</em>:
			</p>
<pre class="prettyprint lang-js">var server = require("./server");
var router = require("./router");
var requestHandlers = require("./requestHandlers");

var handle = {}
handle["/"] = requestHandlers.start;
handle["/start"] = requestHandlers.start;
handle["/upload"] = requestHandlers.upload;

server.start(router.route, handle);
</pre>
			<p>
				Although <em>handle</em> is more of a "thing" (a collection of
				request handlers), I propose we name it like a verb, because
				this will result in a fluent expression in our router, as we
				will see soon.
			</p>
			<p>
				As you can see, it's really simple to map different URLs to the
				same request handler: by adding a key/value pair of
				<em>"/"</em> and <em>requestHandlers.start</em>, we can express
				in a nice and clean way that not only requests to
				<em>/start</em>, but also requests to <em>/</em> shall be
				handled by the <em>start</em> handler.
			</p>
			<p>
				After defining our object, we pass it into the server as an
				additional parameter. Let's change our <em>server.js</em> to
				make use of	it:
			</p>
<pre class="prettyprint lang-js">var http = require("http");
var url = require("url");

function start(route, handle) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log("Request for " + pathname + " received.");

    route(handle, pathname);

    response.writeHead(200, {"Content-Type": "text/html"});
    response.write("Hello World");
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("Server has started.");
}

exports.start = start;
</pre>
			<p>
				We've added the <em>handle</em> parameter to our
				<em>start()</em> function, and pass the handle object on to
				the <em>route()</em> callback, as its first parameter.
			</p>
			<p>
				Let's change the <em>route()</em> function accordingly, in our
				<em>router.js</em> file:
			</p>
<pre class="prettyprint lang-js">function route(handle, pathname) {
  console.log("About to route a request for " + pathname);
  if (typeof handle[pathname] === 'function') {
	  handle[pathname]();
  } else {
	  console.log("No request handler found for " + pathname);
  }
}

exports.route = route;
</pre>
			<p>
				What we do here is, we check if a request handler for the given
				pathname exists, and if it does, we simply call the according
				function. Because we can access our request handler functions
				from our object just as we would access an element of an
				associative array, we have this nice fluent
				<em>handle[pathname]();</em> expression I talked about earlier:
				"Please, <em>handle</em> this <em>pathname</em>".
			</p>
			<p>
				Ok, that's all we need to wire server, router, and request
				handlers together! When starting our application and requesting
				<a href="http://localhost:8888/start" rel="nofollow">http://localhost:8888/start</a>
				in our browser, we can prove that the correct request handler
				was indeed called:
			</p>
<pre>Server has started.
Request for /start received.
About to route a request for /start
Request handler 'start' was called.
</pre>
			<p>
				And opening <a href="http://localhost:8888/" rel="nofollow">http://localhost:8888/</a>
				in our browser proves that these requests, too, are indeed handled by
				the <em>start</em> request handler:
			</p>
<pre>Request for / received.
About to route a request for /
Request handler 'start' was called.
</pre>


			<h4>Making the request handlers respond</h4>
			<p>
				Beautiful. Now if only the request handlers could actually send
				something back to the browser, that would be even better,
				right?
			</p>
			<p>
				Remember, the "Hello World" your browser displays upon
				requesting a page still comes from the <em>onRequest</em>
				function in our <em>server.js</em> file.
			</p>
			<p>
				"Handling request" means "answering requests" after all, thus
				we need to enable our request handlers to speak with the
				browser just like our <em>onRequest</em> function does.
			</p>

			<h5>How to not do it</h5>
			<p>
				The straight-forward approach we -  as developers with a
				background in PHP or Ruby - might want to follow is actually
				very deceitful: it works like a charm, seems to make a lot of
				sense, and then suddenly screws things up when we don't expect
				it.
			</p>
			<p>
				What I mean by "straight-forward approach" is this: make the
				request handlers <em>return()</em> the content they want to
				display to the user, and send this response data in the
				<em>onRequest</em> function back to the user.
			</p>
			<p>
				Let's just do this, and then see why it's not such an overly
				good idea.
			</p>
			<p>
				We start with the request handlers and make them return what we
				would like to display in the browser. We need to change
				<em>requestHandlers.js</em> to this:
			</p>
<pre class="prettyprint lang-js">function start() {
  console.log("Request handler 'start' was called.");
  return "Hello Start";
}

function upload() {
  console.log("Request handler 'upload' was called.");
  return "Hello Upload";
}

exports.start = start;
exports.upload = upload;
</pre>
			<p>
				Good. Likewise, the router needs to return to the server what
				the request handlers return to him. We therefore need to edit
				<em>router.js</em> like this:
			</p>
<pre class="prettyprint lang-js">function route(handle, pathname) {
  console.log("About to route a request for " + pathname);
  if (typeof handle[pathname] === 'function') {
    return handle[pathname]();
  } else {
    console.log("No request handler found for " + pathname);
    return "404 Not found";
  }
}

exports.route = route;
</pre>
			<p>
				As you can see, we also return some text if the request could
				not be routed.
			</p>
			<p>
				And last but not least, we need to refactor our server to make
				it respond to the browser with the content the request handlers
				returned via the router, transforming <em>server.js</em> into:
			</p>
<pre class="prettyprint lang-js">var http = require("http");
var url = require("url");

function start(route, handle) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log("Request for " + pathname + " received.");

    response.writeHead(200, {"Content-Type": "text/html"});
	var content = route(handle, pathname)
	response.write(content);
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("Server has started.");
}

exports.start = start;
</pre>
			<p>
				If we start our rewritten application, everything works like
				a charm: requesting <a href="http://localhost:8888/start" rel="nofollow">http://localhost:8888/start</a>
				results in "Hello Start" being displayed in the browser,
				requesting <a href="http://localhost:8888/upload" rel="nofollow">http://localhost:8888/upload</a>
				gives us "Hello Upload", and <a href="http://localhost:8888/foo" rel="nofollow">http://localhost:8888/foo</a>
				produces "404 Not found".
			</p>
			<p>
				Ok, then why is that a problem? The short answer: because we
				will run into problems if one the request handlers wants to make
				use of a non-blocking operation in the future.
			</p>
			<p>
				Let's take a bit more time for the long answer.
			</p>

			<h5>Blocking and non-blocking</h5>
			<p>
				As said, the problems will arise when we include non-blocking
				operations in the request handlers. But let's talk about
				blocking operations first, then about non-blocking operations.
			</p>
			<p>
				And instead of trying to explain what "blocking" and
				"non-blocking" means, let's demonstrate ourselves what happens
				if we add a	blocking operation to our request handlers.
			</p>
			<p>
				To do this, we will modify our <em>start</em> request handler
				to make it wait 10 seconds before returning its "Hello Start"
				string. Because there is no such thing as <em>sleep()</em> in
				JavaScript, we will use a clever hack for that.
			</p>
			<p>
				Please modify <em>requestHandlers.js</em> as follows:
			</p>
<pre class="prettyprint lang-js">function start() {
  console.log("Request handler 'start' was called.");

  function sleep(milliSeconds) {
    var startTime = new Date().getTime(); // get the current time
    while (new Date().getTime() &lt; startTime + milliSeconds); // hog cpu
  }

  sleep(10000);
  return "Hello Start";
}

function upload() {
  console.log("Request handler 'upload' was called.");
  return "Hello Upload";
}

exports.start = start;
exports.upload = upload;
</pre>
			<p>
				Just to make clear what that does: when the function
				<em>start()</em> is called, Node.js waits 10 seconds and only then
				returns "Hello Start". When calling <em>upload()</em>, it
				returns immediately, just like before.
			</p>
			<p>
				(Of course, you should imagine that instead of sleeping for
				10 seconds, there would be a real life blocking operation in
				<em>start()</em>, like some sort of long-running computation.)
			</p>
			<p>
				Let's see what this change does.
			</p>
			<p>
				As always, we need to restart our server. This time, I ask you
				to follow a slightly complex "protocol" in order to see what
				happens: First, open two browser windows or tabs. In the first
				browser window, please enter <a href="http://localhost:8888/start" rel="nofollow">http://localhost:8888/start</a>
				into the address bar, but do not yet open this url!
			</p>
			<p>
				In the second browser window's address bar, enter <a href="http://localhost:8888/upload" rel="nofollow">http://localhost:8888/upload</a>,
				and again, please do not yet hit enter.
			</p>
			<p>
				Now, do as follows: hit enter on the first window ("/start"),
				then quickly change to the second window ("/upload") and hit
				enter, too.
			</p>
			<p>
				What you will notice is this: The /start URL takes 10 seconds
				to load, as we would expect. But the /upload URL <em>also</em>
				takes 10 seconds to load, although there is no <em>sleep()</em>
				in the according request handler!
			</p>
			<p>
				Why? Because <em>start()</em> contains a blocking operation.
				Like in "it's blocking everything else from working".
			</p>
			<p>
				And that is a problem, because, as the saying goes: <em>"In
				node, everything runs in parallel, except your code"</em>.
			</p>
			<p>
				What that means is that Node.js can handle a lot of concurrent
				stuff, but doesn't do this by splitting everything into
				threads - in fact, Node.js is single-threaded. Instead, it does
				so by running an event loop, and we the developers can make use
				of this - we should avoid blocking operations whenever
				possible, and use non-blocking operations instead.
			</p>
			<p>
				But to do so, we need to make use of callbacks by passing
				functions around to other functions that might do something
				that takes some time (like, e.g. sleep for 10 seconds, or query
				a database, or do some expensive calculation).
			</p>
			<p>
				This way we are saying <em>"Hey, probablyExpensiveFunction(),
				please do your stuff, but I, the single Node.js thread, am not
				going to wait right here until you are finished, I will
				continue to execute the lines of code below you, so would you
				please take this callbackFunction() here and call it when
				you are finished doing your expensive stuff? Thanks!"</em>
			</p>
			<p>
				(If you would like to read about that in more detail, please have
				a look at Mixu's post on <a href="http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/">Understanding the node.js event loop</a>.)
			</p>
			<p>
				And we will now see why the way we constructed the "request
				handler response handling" in our application doesn't allow us
				to make proper use of non-blocking operations.
			</p>
			<p>
				Once again, let's try to experience the problem first-hand by
				modifying our application.
			</p>
			<p>
				We are going to use our <em>start</em> request handler for this
				again. Please modify it to reflect the following (file
				<em>requestHandlers.js</em>):
			</p>
<pre class="prettyprint lang-js">var exec = require("child_process").exec;

function start() {
  console.log("Request handler 'start' was called.");
  var content = "empty";

  exec("ls -lah", function (error, stdout, stderr) {
    content = stdout;
  });

  return content;
}

function upload() {
  console.log("Request handler 'upload' was called.");
  return "Hello Upload";
}

exports.start = start;
exports.upload = upload;
</pre>
			<p>
				As you can see, we just introduced a new Node.js module,
				<em>child_process</em>. We did so because it allows us to make
				use of a very simple yet useful non-blocking operation:
				<em>exec()</em>.
			</p>
			<p>
				What <em>exec()</em> does is, it executes a shell command from
				within Node.js. In this example, we are going to use it to get
				a list of all files in the current directory ("ls -lah"),
				allowing us to display this list in the browser of a user
				requesting the <em>/start</em> URL.
			</p>
			<p>
				What the code does is straightforward: create a new variable
				<em>content</em> (with an initial value of "empty"), execute
				"ls -lah", fill the	variable with the result, and return it.
			</p>
			<p>
				As always, we will start our application, and visit
				<a href="http://localhost:8888/start" rel="nofollow">http://localhost:8888/start</a>.
			</p>
			<p>
				Which loads a beautiful web page that displays the string
				"empty". What's going wrong here?
			</p>
			<p>
				Well, as you may have already guessed, <em>exec()</em> does its
				magic in a non-blocking fashion. That's a good thing, because
				this way we can execute very expensive shell operations (like,
				e.g., copying huge files around or similar stuff) without
				forcing our application into a full stop as the blocking
				<em>sleep</em> operation did.
			</p>
			<p>
				(If you would like to prove this, replace "ls -lah" with a
				more expensive operation like "find /").
			</p>
			<p>
				But we aren't exactly happy with our elegant non-blocking
				operation, when our browser doesn't display its result, right?
			</p>
			<p>
				Well, then, let's fix it. And while we are at it, let's try to
				understand why the current architecture doesn't work.
			</p>
			<p>
				The problem is that <em>exec()</em>, in order to work
				non-blocking, makes use of a callback function.
			</p>
			<p>
				In our example, it's an anonymous function which is passed as
				the second parameter to the <em>exec()</em> function call:
			</p>
<pre class="prettyprint lang-js">function (error, stdout, stderr) {
  content = stdout;
}
</pre>
			<p>
				And herein lies the root of our problem: our own code is
				executed synchronous, which means that immediately after
				calling <em>exec()</em>, Node.js continues to execute
				<em>return content;</em>. At this point, <em>content</em> is
				still "empty", due to the fact that the callback function
				passed to <em>exec()</em> has not yet been called - because
				<em>exec()</em> operates asynchronous.
			</p>
			<p>
				Now, "ls -lah" is a very inexpensive and fast operation (unless
				there are millions of files in the directory). Which is why the
				callback is called relatively expeditious - but it nevertheless
				happens asynchronously.
			</p>
			<p>
				Thinking about a more expensive command	makes this more
				obvious: "find /" takes about 1 minute on my
				machine, but if I replace "ls -lah" with "find /" in the
				request handler, I still immediately receive an HTTP response
				when opening the /start URL - it's clear that <em>exec()</em>
				does something in the background, while Node.js itself
				continues with the application, and we may assume that the
				callback function we passed into <em>exec()</em> will be called
				only when the "find /" command has finished running.
			</p>
			<p>
				But how can we achieve our goal, i.e. showing the user a list
				of files in the current directory?
			</p>
			<p>
				Well, after learning how to <em>not</em> do it, let's discuss
				how to make our request handlers respond to browser requests
				the right way.
			</p>

			<h5>Responding request handlers with non-blocking operations</h5>
			<p>
				I've just used the phrase "the right way". Dangerous stuff.
				Quite often, there is no single "right way".
			</p>
			<p>
				But one possible solution for this is, as often with Node.js,
				to pass functions around. Let's examine this.
			</p>
			<p>
				Right now, our application is able to transport the content
				(which the request handlers would like to display to the user)
				from the request handlers to the HTTP server by returning it
				up through the layers of the application (request handler -&gt;
				router -&gt; server).
			</p>
			<p>
				Our new approach is as follows: instead of bringing the content
				to the server, we will bring the server to the content. To be
				more precise, we will inject the <em>response</em> object (from
				our server's callback function <em>onRequest()</em>) through
				the router into the request handlers. The handlers will then be
				able to use this object's functions to respond to requests
				themselves.
			</p>
			<p>
				Enough explanation, here is the step by step recipe on how to
				change our application.
			</p>
			<p>
				Let's start with our <em>server.js</em>:
			</p>
<pre class="prettyprint lang-js">var http = require("http");
var url = require("url");

function start(route, handle) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log("Request for " + pathname + " received.");

    route(handle, pathname, response);
  }

  http.createServer(onRequest).listen(8888);
  console.log("Server has started.");
}

exports.start = start;
</pre>
			<p>
				Instead of expecting a return value from the <em>route()</em>
				function, we pass it a third parameter, our <em>response</em>
				object. Furthermore, we removed any <em>response</em> method
				calls from the <em>onRequest()</em> handler, because we now
				expect <em>route</em> to take care of that.
			</p>
			<p>
				Next comes <em>router.js</em>:
			</p>
<pre class="prettyprint lang-js">function route(handle, pathname, response) {
  console.log("About to route a request for " + pathname);
  if (typeof handle[pathname] === 'function') {
    handle[pathname](response);
  } else {
    console.log("No request handler found for " + pathname);
    response.writeHead(404, {"Content-Type": "text/html"});
    response.write("404 Not found");
    response.end();
  }
}

exports.route = route;
</pre>
			<p>
				Same pattern: instead of expecting a return value from our
				request handlers, we pass the <em>respond</em> object on.
			</p>
			<p>
				If no request handler can be used, we now take care of
				responding with a proper "404" header and body ourselves.
			</p>
			<p>
				And last but not least, we modify <em>requestHandlers.js</em>:
			</p>
<pre class="prettyprint lang-js">var exec = require("child_process").exec;

function start(response) {
  console.log("Request handler 'start' was called.");

  exec("ls -lah", function (error, stdout, stderr) {
    response.writeHead(200, {"Content-Type": "text/html"});
    response.write(stdout);
    response.end();
  });
}

function upload(response) {
  console.log("Request handler 'upload' was called.");
  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("Hello Upload");
  response.end();
}

exports.start = start;
exports.upload = upload;
</pre>
			<p>
				Our handler functions need to accept the response parameter,
				and have to make use of them in order to respond to the
				request directly.
			</p>
			<p>
				The <em>start</em> handler will respond from within the
				anonymous <em>exec()</em> callback, and the <em>upload</em>
				handler still simply replies with "Hello Upload", but now
				by making use of the <em>response</em> object.
			</p>
			<p>
				If we start our application again (<em>node index.js</em>),
				this should work as expected.
			</p>
			<p>
				If you would like to prove that an expensive operation behind
				<em>/start</em> will no longer block requests for
				<em>/upload</em> from answering immediately, then modify your
				<em>requestHandlers.js</em> as follows:
			</p>
<pre class="prettyprint lang-js">var exec = require("child_process").exec;

function start(response) {
  console.log("Request handler 'start' was called.");

  exec("find /",
    { timeout: 10000, maxBuffer: 20000*1024 },
    function (error, stdout, stderr) {
      response.writeHead(200, {"Content-Type": "text/html"});
      response.write(stdout);
      response.end();
    });
}

function upload(response) {
  console.log("Request handler 'upload' was called.");
  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("Hello Upload");
  response.end();
}

exports.start = start;
exports.upload = upload;
</pre>
			<p>
				This will make HTTP requests to <a href="http://localhost:8888/start" rel="nofollow">http://localhost:8888/start</a>
				take at least 10 seconds, but requests to <a href="http://localhost:8888/upload" rel="nofollow">http://localhost:8888/upload</a>
				will be answered immediately, even if /start is still
				computing.
			</p>
			<p>
				Enough for today. Upcoming next: Handling file uploads.
			</p>
		</div>




		
		<div id="workinprogressnote">
			<p>
				The Node Beginner Book is work in progress.
				<br />
				<strong>It's currently about 80% done.</strong>
				<br />
				Check back daily to see the latest version.
			</p>
			<p>
				The version you are	currently reading was updated on
				<br />
				<strong>Sunday, April 24, 2011 at 6:52 AM EDT</strong>.
			</p>
			<p>
				The best way to stay informed about updates is to follow
				<br />
				<a href="http://twitter.com/manuelkiessling">@ManuelKiessling on Twitter</a>.
			</p>
		</div>


		<div id="praise">
			<div class="praise">
				<div class="comment">
					"I love nodebeginner.org - concise, direct to the point and
					even enjoyable to read."
				</div>
				<div class="author">Gojko Adzic, author of <em>Specification by Example</em> and <em>Bridging the Communication Gap</em></div>
			</div>
			<div class="praise">
				<div class="comment">
					"This is one of the best tutorials I've read.
					As a former Java coder, I've always found JavaScript
					to be a black art, but you have really simplified
					things with this tutorial."
				</div>
				<div class="author">Erskine, from the comments</div>
			</div>
			<div class="praise">
				<div class="comment">
					"This is one of the few beginner articles I made it all the
					way through because of how well it's written."
				</div>
				<div class="author">
					Paul Gibler, from the comments
				</div>
			</div>
			<div class="praise">
				<div class="comment">
					"Indispensable."
				</div>
				<div class="author">
					@lecolibrilibre, on Twitter
				</div>
			</div>
			<div class="praise">
				<div class="comment">
					"I just wanted to drop you a note to say thank you for
					writing such an excellent introduction to node. Your book's
					explanation is fantastic, and I can't wait for you to
					finish it!"
				</div>
				<div class="author">
					Seth McLaughlin, via eMail
				</div>
			</div>
		</div>

		<div id="donate">
			<p>
				<em>The Node Beginner Book</em> is and will always be available for free.
				<br />
				Furthermore, no money is needed to keep the project alive and progressing.
				<br />
				But if you would like to support the author, you can do so using Flattr or PayPal:
			</p>
			<div id="flattr">
				<a class="FlattrButton" style="display:none;" href="http://www.nodebeginner.org"></a>
			</div>
			<div id="paypal">
				<form action="https://www.paypal.com/cgi-bin/webscr" method="post">
					<fieldset>
						<input type="hidden" name="cmd" value="_s-xclick" />
						<input type="hidden" name="hosted_button_id" value="AWJS7PD37SQ5G" />
						<input type="image" src="https://www.paypalobjects.com/WEBSCR-640-20110401-1/en_US/i/btn/btn_donateCC_LG.gif" name="submit" alt="PayPal - The safer, easier way to pay online!" />
						<img alt="" src="https://www.paypalobjects.com/WEBSCR-640-20110401-1/de_DE/i/scr/pixel.gif" width="1" height="1" />
					</fieldset>
				</form>
			</div>

		</div>

		<div id="disqus_thread"></div>
		<script type="text/javascript">
			var disqus_shortname = 'nodebeginner';
			var disqus_identifier = 'nodebeginner-book';
			var disqus_url = 'http://www.nodebeginner.org/';

			(function() {
				var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
				dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
				(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
			})();
		</script>

		<div id="footer">
			<p id="ccimage">
				<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a>
			</p>
			<p>
				<span xmlns:dct="http://purl.org/dc/terms/">The Node Beginner Book</span>
				by
				<a xmlns:cc="http://creativecommons.org/ns#" href="http://manuel.kiessling.net" rel="cc:attributionURL">Manuel Kiessling</a>
				is licensed under a
				<br />
				<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.
				<br />
				Permissions beyond the scope of this license may be available at <a xmlns:cc="http://creativecommons.org/ns#" href="mailto:manuel@kiessling.net" rel="cc:morePermissions">manuel@kiessling.net</a>.
			</p>
		</div>
	</body>
</html>